{"config":{"lang":["de"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"PIXEstL \u2013 Farb-Lithophanie-Generator","text":"<p>PIXEstL verwandelt deine Fotos in hinterleuchtete Farbbilder aus dem 3D-Drucker. Durch clevere Farbmischung aus transparenten Filamenten entstehen Kunstwerke, die im Dunkeln erstrahlen.</p> <p>Jetzt loslegen Installation Galerie ansehen</p>"},{"location":"#was-macht-pixestl-besonders","title":"Was macht PIXEstL besonders?","text":"<ul> <li> <p>CMYK-Farbmischung</p> <p>Wie beim klassischen Vierfarbdruck werden Cyan, Magenta, Gelb und Wei\u00df zu tausenden Farbt\u00f6nen gemischt \u2013 nur eben in 3D und aus transparentem Filament.</p> </li> <li> <p>Bambu Lab AMS-Unterst\u00fctzung</p> <p>Volle Unterst\u00fctzung f\u00fcr das Automatic Material System (AMS). PIXEstL teilt die Farben automatisch in Gruppen auf, die perfekt in 1, 2 oder 4 AMS-Einheiten passen.</p> </li> <li> <p>Hochperformant</p> <p>In Rust geschrieben mit paralleler Verarbeitung \u00fcber alle CPU-Kerne. Typische Bilder werden in Sekunden verarbeitet \u2013 2\u20133\u00d7 schneller als die Java-Vorg\u00e4ngerversion.</p> </li> </ul>"},{"location":"#so-funktioniert-es-in-5-schritten","title":"So funktioniert es \u2013 in 5 Schritten","text":"<pre><code>graph LR\n    A[\"\ud83d\udcf7 Foto w\u00e4hlen\"] --&gt; B[\"\ud83c\udfa8 Palette kalibrieren\"]\n    B --&gt; C[\"\u2699\ufe0f PIXEstL ausf\u00fchren\"]\n    C --&gt; D[\"\ud83d\udda8\ufe0f Slicer einrichten\"]\n    D --&gt; E[\"\u2705 Drucken &amp; beleuchten\"]</code></pre> Schritt Was passiert Mehr erfahren 1. Palette kalibrieren Du misst einmalig, wie deine Filamente hinterleuchtet aussehen, und tr\u00e4gst die Werte in eine JSON-Datei ein. Kalibrierung \u2192 2. Bild vorbereiten Du w\u00e4hlst ein passendes Foto und optimierst es kurz (Kontrast, Ausschnitt, Gr\u00f6\u00dfe). Bild vorbereiten \u2192 3. PIXEstL ausf\u00fchren Ein einzelner Befehl rechnet das Bild in mehrere STL-Dateien um \u2013 je eine pro Filamentfarbe. Generierung \u2192 4. Slicer einrichten Du l\u00e4dst die STL-Dateien in Bambu Studio und weist jeder Datei das richtige Filament zu. Slicer \u2192 5. Drucken &amp; beleuchten Der Drucker \u00fcbernimmt \u2013 danach einfach eine Lichtquelle dahinter und staunen. Drucken \u2192"},{"location":"#beispiele","title":"Beispiele","text":"<p>Alle Beispiele in der Galerie \u2192</p>"},{"location":"ARCHITECTURE/","title":"PIXEstL Architecture Documentation","text":""},{"location":"ARCHITECTURE/#overview","title":"Overview","text":"<p>PIXEstL is a command-line tool for creating color lithophanes for 3D printing with multi-color filaments (CMYK-based additive color mixing). This document provides a comprehensive analysis of the Java implementation to guide the Rust port.</p>"},{"location":"ARCHITECTURE/#high-level-architecture","title":"High-Level Architecture","text":"<pre><code>graph TD\n    A[CLI Arguments] --&gt; B[CommandArgsParser]\n    B --&gt; C[GenInstruction]\n    C --&gt; D[PlateGenerator]\n    D --&gt; E[Palette]\n    D --&gt; F[ImageUtil]\n    E --&gt; G[Color Quantization]\n    F --&gt; H[Image Resize/Process]\n    G --&gt; I[StlMaker]\n    H --&gt; I\n    I --&gt; J[CSG Threads]\n    J --&gt; K[Color Layers STL]\n    J --&gt; L[Texture Layer STL]\n    J --&gt; M[Support Plate STL]\n    K --&gt; N[ZIP Output]\n    L --&gt; N\n    M --&gt; N</code></pre>"},{"location":"ARCHITECTURE/#module-breakdown","title":"Module Breakdown","text":""},{"location":"ARCHITECTURE/#1-entry-point-cli","title":"1. Entry Point &amp; CLI","text":"<p>Java Classes: - <code>Main.java</code> - Entry point - <code>CommandArgsParser.java</code> - CLI argument parsing using Apache Commons CLI - <code>GenInstruction.java</code> - Configuration data structure</p> <p>Responsibilities: - Parse CLI arguments - Validate input parameters - Create configuration object - Invoke main processing pipeline</p> <p>Key Parameters: - Input image path, palette path - Output dimensions (width/height in mm) - Pixel dimensions (color pixel width, texture pixel width) - Layer configuration (number of layers, thickness) - Color distance method (RGB, CIELab) - Pixel creation method (ADDITIVE, FULL) - Thread configuration for parallel processing</p>"},{"location":"ARCHITECTURE/#2-palette-module","title":"2. Palette Module","text":"<p>Java Classes: - <code>Palette.java</code> - Palette management and color quantization - <code>ColorLayer.java</code> - Single color layer with CMYK values - <code>ColorCombi.java</code> - Combination of color layers</p> <p>Responsibilities:</p>"},{"location":"ARCHITECTURE/#21-palette-loading","title":"2.1 Palette Loading","text":"<ul> <li>Load JSON palette file</li> <li>Parse filament definitions with layers</li> <li>Each filament has:</li> <li>Hex code (e.g., <code>#0086D6</code>)</li> <li>Name (e.g., \"Cyan[PLA Basic]\")</li> <li>Active flag</li> <li>Layers (1-5) with HSL or hex values</li> </ul>"},{"location":"ARCHITECTURE/#22-color-combination-generation","title":"2.2 Color Combination Generation","text":"<p>Algorithm for ADDITIVE mode: 1. Read all active filaments from palette 2. For each filament, extract layers (1-5) with HSL values 3. Convert HSL \u2192 CMYK for each layer 4. Generate all possible combinations that sum to <code>colorPixelLayerNumber</code> layers (default: 5) 5. Compute final color by:    - Sum CMYK values of all layers in combination    - Clamp CMYK values to [0, 1]    - Convert CMYK \u2192 RGB for comparison</p> <p>Example: - Cyan Layer 3 (0.3mm) + Magenta Layer 2 (0.2mm) = 5 layers total - CMYK: (C\u2081+C\u2082, M\u2081+M\u2082, Y\u2081+Y\u2082, K\u2081+K\u2082) \u2192 RGB</p>"},{"location":"ARCHITECTURE/#23-color-quantization","title":"2.3 Color Quantization","text":"<p>Algorithm: 1. For each pixel in source image:    - Skip transparent pixels    - Find closest color from pre-computed ColorCombi list    - Use color distance metric (RGB or CIELab) 2. Parallel processing using thread pool 3. Return quantized image with palette colors only</p>"},{"location":"ARCHITECTURE/#24-multi-group-support-ams-with-limited-colors","title":"2.4 Multi-Group Support (AMS with limited colors)","text":"<ul> <li>If <code>colorNumber</code> is set (e.g., 4 for one AMS):</li> <li>Split filaments into groups</li> <li>Each group has max <code>colorNumber-1</code> colors (+ white)</li> <li>Generate swap instructions for layer changes</li> </ul>"},{"location":"ARCHITECTURE/#3-color-utilities","title":"3. Color Utilities","text":"<p>Java Class: <code>ColorUtil.java</code></p> <p>Color Spaces:</p>"},{"location":"ARCHITECTURE/#rgb-red-green-blue","title":"RGB (Red, Green, Blue)","text":"<ul> <li>Standard 8-bit per channel (0-255)</li> <li>Used for image I/O and basic operations</li> </ul>"},{"location":"ARCHITECTURE/#hsl-hue-saturation-lightness","title":"HSL (Hue, Saturation, Lightness)","text":"<ul> <li>Hue: 0-360 degrees</li> <li>Saturation: 0-100%</li> <li>Lightness: 0-100%</li> <li>Used in palette JSON for layer definitions</li> </ul>"},{"location":"ARCHITECTURE/#cmyk-cyan-magenta-yellow-keyblack","title":"CMYK (Cyan, Magenta, Yellow, Key/Black)","text":"<ul> <li>Each component: 0.0-1.0</li> <li>Used for additive color mixing</li> <li>Formula: HSL \u2192 RGB \u2192 CMYK</li> </ul>"},{"location":"ARCHITECTURE/#cielab","title":"CIELab","text":"<ul> <li>L: Lightness (0-100)</li> <li>a: Green-Red axis</li> <li>b: Blue-Yellow axis</li> <li>Perceptually uniform color space</li> <li>Used for accurate color distance</li> </ul> <p>Conversion Pipeline: <pre><code>HSL \u2192 RGB (via hueToRgb helper)\nRGB \u2192 XYZ (D65 illuminant)\nXYZ \u2192 CIELab (using pivot functions)\n</code></pre></p> <p>Color Distance Algorithms:</p> <ol> <li> <p>RGB Distance (Euclidean): <pre><code>d = \u221a((R\u2081-R\u2082)\u00b2 + (G\u2081-G\u2082)\u00b2 + (B\u2081-B\u2082)\u00b2)\n</code></pre></p> </li> <li> <p>CIELab Distance (Delta E - CIE76): <pre><code>\u0394E = \u221a((L\u2081-L\u2082)\u00b2 + (a\u2081-a\u2082)\u00b2 + (b\u2081-b\u2082)\u00b2)\n</code></pre></p> </li> <li>More perceptually accurate than RGB</li> <li>Default method in PIXEstL</li> </ol>"},{"location":"ARCHITECTURE/#4-image-processing","title":"4. Image Processing","text":"<p>Java Class: <code>ImageUtil.java</code></p> <p>Operations:</p>"},{"location":"ARCHITECTURE/#41-image-resizing","title":"4.1 Image Resizing","text":"<ul> <li>Calculate pixel count based on physical dimensions (mm) and pixel size (mm)</li> <li>Preserve aspect ratio if only width or height is specified</li> <li>Use Java2D for resampling</li> </ul>"},{"location":"ARCHITECTURE/#42-grayscale-conversion","title":"4.2 Grayscale Conversion","text":"<ul> <li>Formula (BT.709 standard):   <pre><code>Luminance = 0.2126 * R + 0.7152 * G + 0.0722 * B\n</code></pre></li> <li>Used for texture layer generation</li> </ul>"},{"location":"ARCHITECTURE/#43-transparency-handling","title":"4.3 Transparency Handling","text":"<ul> <li>Check alpha channel (TYPE_INT_ARGB)</li> <li>Transparent pixels skipped in color quantization</li> <li>Transparency creates cutouts in final STL</li> </ul>"},{"location":"ARCHITECTURE/#44-image-flipping","title":"4.4 Image Flipping","text":"<ul> <li>Vertical flip (mirror Y-axis) before STL generation</li> <li>Corrects coordinate system mismatch</li> </ul>"},{"location":"ARCHITECTURE/#5-stl-generation-csg","title":"5. STL Generation &amp; CSG","text":"<p>Java Classes: - <code>StlMaker.java</code> - Main STL generation orchestrator - <code>CSGWorkData.java</code> - Shared data structure for CSG threads - <code>CSGThread*.java</code> - Thread implementations for parallel processing</p> <p>Architecture:</p>"},{"location":"ARCHITECTURE/#51-thread-based-processing","title":"5.1 Thread-Based Processing","text":"<ul> <li>Executor service with configurable thread pool</li> <li>Separate threads for:</li> <li>Each color layer group</li> <li>Texture layer</li> <li>Support plate</li> <li>Row-based parallelization within each thread</li> </ul>"},{"location":"ARCHITECTURE/#52-layer-types","title":"5.2 Layer Types","text":"<p>Color Layers (CSGThreadColor): - One STL file per color/color group - For each pixel with this color:   - Create cuboid at (x, y) position   - Width/Height: <code>colorPixelWidth</code> (default 0.8mm)   - Thickness: Sum of layers for this color in ColorCombi   - Z-offset: Based on position in layer stack</p> <p>Texture Layer (CSGThreadTexture): - Single STL file (usually white) - For each pixel:   - Grayscale value \u2192 height mapping   - Black (0) \u2192 <code>textureMinThickness</code> (default 0.2mm)   - White (255) \u2192 <code>textureMaxThickness</code> (default 2.5mm)   - Linear interpolation for intermediate values - Creates 3D relief effect</p> <p>Support Plate (CSGSupportPlate): - Base plate at Z=0 - Thickness: <code>plateThickness</code> (default 0.2mm) - Covers entire image area - Handles transparency (creates holes for transparent pixels)</p>"},{"location":"ARCHITECTURE/#53-csg-operations","title":"5.3 CSG Operations","text":"<ul> <li>Uses JCSG library (Java Constructive Solid Geometry)</li> <li>Operations: union, difference, intersection</li> <li>Generates triangle meshes</li> <li>Binary STL output</li> </ul>"},{"location":"ARCHITECTURE/#6-output-generation","title":"6. Output Generation","text":"<p>Format: ZIP archive containing: - <code>layer-&lt;color&gt;.stl</code> - One per active color - <code>layer-plate.stl</code> - Support plate - <code>layer-texture-&lt;color&gt;.stl</code> - Texture layer - <code>image-color-preview.png</code> - Quantized color preview - <code>image-texture-preview.png</code> - Grayscale texture preview - <code>instructions.txt</code> - Filament swap instructions (if using AMS mode)</p>"},{"location":"ARCHITECTURE/#data-flow","title":"Data Flow","text":""},{"location":"ARCHITECTURE/#main-processing-pipeline","title":"Main Processing Pipeline","text":"<pre><code>1. Parse CLI Arguments\n   \u2193\n2. Load Palette JSON\n   \u2192 Parse filament definitions\n   \u2192 Generate ColorCombi list (all possible layer combinations)\n   \u2193\n3. Load &amp; Process Source Image\n   \u2192 Resize for color processing (colorPixelWidth)\n   \u2192 Resize for texture processing (texturePixelWidth)\n   \u2193\n4. Color Quantization (if colorLayer=true)\n   \u2192 For each pixel: find closest ColorCombi\n   \u2192 Parallel processing using thread pool\n   \u2192 Store mapping: RGB \u2192 ColorCombi\n   \u2193\n5. Grayscale Conversion (if textureLayer=true)\n   \u2192 Convert to luminance values\n   \u2193\n6. Flip Images\n   \u2192 Vertical flip for STL coordinate system\n   \u2193\n7. Generate STL Files (Parallel)\n   \u2192 Color Layers: Per-color threads\n   \u2192 Texture Layer: Single thread\n   \u2192 Support Plate: Single thread or fast generation\n   \u2193\n8. Package Output\n   \u2192 Create ZIP archive\n   \u2192 Add all STL files\n   \u2192 Add preview images\n   \u2192 Add instructions (if applicable)\n</code></pre>"},{"location":"ARCHITECTURE/#key-algorithms","title":"Key Algorithms","text":""},{"location":"ARCHITECTURE/#algorithm-1-colorcombi-generation","title":"Algorithm 1: ColorCombi Generation","text":"<p>Purpose: Generate all possible color combinations that sum to exactly N layers.</p> <p>Input: - List of ColorLayer objects (from palette) - Target layer count (e.g., 5)</p> <p>Output: - List of ColorCombi objects</p> <p>Pseudocode: <pre><code>function createMultiCombi(colorLayers, targetLayers):\n    result = []\n\n    for each colorLayer in colorLayers:\n        # Single layer\n        combi = ColorCombi(colorLayer)\n        if combi.totalLayers == targetLayers:\n            result.add(combi)\n\n        # Recursive combinations\n        if combi.totalLayers &lt; targetLayers:\n            subCombis = computeCombination(combi, colorLayers, targetLayers)\n            result.addAll(subCombis)\n\n    return result\n\nfunction computeCombination(currentCombi, colorLayers, targetLayers):\n    result = []\n\n    for each colorLayer in colorLayers:\n        # Skip if color already in combination (ADDITIVE mode)\n        if currentCombi.contains(colorLayer.hexCode):\n            continue\n\n        # Skip if would exceed target\n        if currentCombi.totalLayers + colorLayer.layer &gt; targetLayers:\n            continue\n\n        # Create new combination\n        newCombi = currentCombi.combine(colorLayer)\n\n        if newCombi.totalLayers == targetLayers:\n            result.add(newCombi)\n        else:\n            # Recursive call\n            subCombis = computeCombination(newCombi, colorLayers, targetLayers)\n            result.addAll(subCombis)\n\n    return result\n</code></pre></p> <p>Example: - Cyan: layers {5, 4, 3, 2, 1} - Magenta: layers {5, 4, 3, 2, 1} - White: layers {5, 4, 3, 2, 1} - Target: 5 layers</p> <p>Possible combinations: - Cyan(5) - Cyan(3) + White(2) - Cyan(2) + Magenta(3) - Cyan(2) + Magenta(2) + White(1) - etc.</p>"},{"location":"ARCHITECTURE/#algorithm-2-color-quantization-with-threading","title":"Algorithm 2: Color Quantization with Threading","text":"<p>Purpose: Map each pixel to closest palette color using parallel processing.</p> <p>Pseudocode: <pre><code>function quantizeColors(image, paletteColors, distanceMethod):\n    quantizedImage = new Image(image.width, image.height)\n    threadPool = new ThreadPool(numCores)\n    tasks = []\n\n    for y in 0..image.height:\n        for x in 0..image.width:\n            if isTransparent(image, x, y):\n                quantizedImage.setRGB(x, y, TRANSPARENT)\n                continue\n\n            pixelColor = image.getRGB(x, y)\n            task = FindClosestColorTask(x, y, pixelColor, paletteColors, distanceMethod)\n            threadPool.execute(task)\n            tasks.add(task)\n\n    threadPool.shutdown()\n    threadPool.awaitTermination(timeout)\n\n    for task in tasks:\n        quantizedImage.setRGB(task.x, task.y, task.closestColor)\n\n    return quantizedImage\n</code></pre></p>"},{"location":"ARCHITECTURE/#algorithm-3-texture-height-mapping","title":"Algorithm 3: Texture Height Mapping","text":"<p>Purpose: Convert grayscale values to 3D height for texture layer.</p> <p>Formula: <pre><code>height = minThickness + (luminance / 255) * (maxThickness - minThickness)\n</code></pre></p> <p>Where: - luminance: 0 (black) to 255 (white) - minThickness: Default 0.2mm - maxThickness: Default 2.5mm</p> <p>Effect: - Dark areas: thinner (more light passes through) - Light areas: thicker (less light passes through) - Creates relief/depth effect when backlit</p>"},{"location":"ARCHITECTURE/#java-to-rust-mapping","title":"Java-to-Rust Mapping","text":""},{"location":"ARCHITECTURE/#module-mapping","title":"Module Mapping","text":"Java Package Rust Module Description <code>ggo.pixestl.arg</code> <code>src/cli.rs</code>, <code>src/config.rs</code> CLI parsing and configuration <code>ggo.pixestl.generator</code> <code>src/lib.rs</code>, <code>src/lithophane/generator.rs</code> Main orchestration <code>ggo.pixestl.palette</code> <code>src/palette/</code> Palette loading and color combinations <code>ggo.pixestl.util.ColorUtil</code> <code>src/color/</code> Color space conversions and distance <code>ggo.pixestl.util.ImageUtil</code> <code>src/image/</code> Image loading and processing <code>ggo.pixestl.stl</code> <code>src/stl/</code> STL file generation <code>ggo.pixestl.csg</code> <code>src/geometry/</code>, <code>src/lithophane/</code> 3D geometry and mesh generation"},{"location":"ARCHITECTURE/#class-to-struct-mapping","title":"Class-to-Struct Mapping","text":"Java Class Rust Equivalent Notes <code>GenInstruction</code> <code>struct Config</code> Configuration with builder pattern <code>Palette</code> <code>struct Palette</code> Owns ColorCombi list <code>ColorLayer</code> <code>struct ColorLayer</code> Immutable data <code>ColorCombi</code> <code>struct ColorCombi</code> Vec of ColorLayer <code>Color</code> (AWT) <code>struct Rgb</code> Custom type for RGB <code>BufferedImage</code> <code>image::RgbaImage</code> From <code>image</code> crate"},{"location":"ARCHITECTURE/#threading-model","title":"Threading Model","text":"<p>Java: - <code>ExecutorService</code> with fixed thread pool - <code>Runnable</code> tasks - <code>awaitTermination</code> for synchronization</p> <p>Rust: - <code>rayon</code> for data parallelism - <code>par_iter()</code> for pixel processing - <code>thread::scope</code> for structured concurrency - <code>Arc&lt;Mutex&lt;T&gt;&gt;</code> for shared mutable state (if needed)</p>"},{"location":"ARCHITECTURE/#dependencies","title":"Dependencies","text":""},{"location":"ARCHITECTURE/#java-from-pomxml","title":"Java (from pom.xml)","text":"Dependency Purpose Rust Equivalent jcsg 0.5.7 CSG operations Manual implementation or <code>cgmath</code> javafx-controls UI (unused in CLI) N/A org.json JSON parsing <code>serde_json</code> commons-cli CLI parsing <code>clap</code>"},{"location":"ARCHITECTURE/#rust-proposed","title":"Rust (proposed)","text":"Crate Version Purpose clap 4 CLI parsing with derive macros image 0.25 Image loading and processing nalgebra 0.33 Linear algebra for 3D math stl_io 0.7 STL file writing serde 1 JSON deserialization serde_json 1 JSON parsing rayon 1.10 Data parallelism thiserror 1 Error type derivation anyhow 1 Error handling zip 2 ZIP archive creation"},{"location":"ARCHITECTURE/#performance-considerations","title":"Performance Considerations","text":""},{"location":"ARCHITECTURE/#bottlenecks-in-java-implementation","title":"Bottlenecks in Java Implementation","text":"<ol> <li>Color Quantization:</li> <li>O(pixels \u00d7 palette_colors) for distance calculation</li> <li>Mitigated by threading</li> <li> <p>Can be optimized with spatial indexing (k-d tree)</p> </li> <li> <p>ColorCombi Generation:</p> </li> <li>Exponential combinations (but pruned early)</li> <li>Typically &lt;10,000 combinations for standard palettes</li> <li> <p>One-time cost at startup</p> </li> <li> <p>STL Generation:</p> </li> <li>Each pixel \u2192 multiple triangles</li> <li>Memory-intensive for large images</li> <li>Java uses \"low memory\" mode with temp files</li> </ol>"},{"location":"ARCHITECTURE/#rust-optimization-opportunities","title":"Rust Optimization Opportunities","text":"<ol> <li>SIMD for Color Distance:</li> <li>Use <code>packed_simd</code> for vectorized distance calculations</li> <li> <p>Process 4-8 colors simultaneously</p> </li> <li> <p>Memory Layout:</p> </li> <li>Struct-of-Arrays (SoA) for ColorCombi list</li> <li> <p>Cache-friendly iteration</p> </li> <li> <p>Parallel Iterator Chains:</p> </li> <li><code>rayon::par_iter()</code> with zero-cost abstraction</li> <li> <p>No thread pool overhead</p> </li> <li> <p>Zero-Copy String Handling:</p> </li> <li>Use <code>&amp;str</code> instead of <code>String</code> where possible</li> <li>Intern color hex codes</li> </ol>"},{"location":"ARCHITECTURE/#special-features","title":"Special Features","text":""},{"location":"ARCHITECTURE/#1-additive-vs-full-mode","title":"1. ADDITIVE vs FULL Mode","text":"<p>ADDITIVE (Default): - Multiple layers of different colors stack - CMYK values add up - Simulates transparent film printing - Requires white (#FFFFFF) as mandatory color</p> <p>FULL: - Each pixel is solid single color - No layer stacking - Simpler but less color accuracy - Used for pixel art style</p>"},{"location":"ARCHITECTURE/#2-ams-automatic-material-system-support","title":"2. AMS (Automatic Material System) Support","text":"<ul> <li>Limit colors per layer group (e.g., 4 colors)</li> <li>Generate multiple layer groups</li> <li>Provide swap instructions at layer boundaries</li> <li>Enables 7+ color prints with 4-slot AMS</li> </ul>"},{"location":"ARCHITECTURE/#3-transparency-handling","title":"3. Transparency Handling","text":"<ul> <li>Images with alpha channel supported</li> <li>Transparent pixels create holes in STL</li> <li>Support plate adapts to image shape</li> <li>Texture layer handles transparency separately</li> </ul>"},{"location":"ARCHITECTURE/#4-curve-mode-advanced","title":"4. Curve Mode (Advanced)","text":"<ul> <li>Parameter: curve value (default 0.0 = off)</li> <li>Splits color layers into multiple plates</li> <li>Creates flexible/curved lithophanes</li> <li>Not compatible with transparency</li> </ul>"},{"location":"ARCHITECTURE/#testing-strategy","title":"Testing Strategy","text":""},{"location":"ARCHITECTURE/#unit-tests-per-module","title":"Unit Tests (Per Module)","text":"<ol> <li>Color Module:</li> <li>RGB \u2194 HSL conversions (known values)</li> <li>RGB \u2192 CIELab (standard test colors)</li> <li> <p>Delta E calculations (symmetric, triangle inequality)</p> </li> <li> <p>Palette Module:</p> </li> <li>JSON parsing (valid/invalid files)</li> <li>ColorCombi generation (count, correctness)</li> <li> <p>Color quantization (deterministic output)</p> </li> <li> <p>Image Module:</p> </li> <li>Resize operations (dimensions)</li> <li>Grayscale conversion (luminance formula)</li> <li> <p>Transparency detection</p> </li> <li> <p>Geometry Module:</p> </li> <li>Mesh generation (triangle count, normals)</li> <li>STL formatting (binary structure)</li> </ol>"},{"location":"ARCHITECTURE/#integration-tests","title":"Integration Tests","text":"<ol> <li>End-to-End:</li> <li>Full pipeline with test image + palette</li> <li>Verify ZIP contents</li> <li> <p>Compare STL file sizes</p> </li> <li> <p>Reference Tests:</p> </li> <li>Run both Java and Rust versions</li> <li>Compare quantized images (should be identical)</li> <li>Compare STL vertex counts (within tolerance)</li> </ol>"},{"location":"ARCHITECTURE/#property-based-tests","title":"Property-Based Tests","text":"<ul> <li>Color distance is symmetric: d(a,b) = d(b,a)</li> <li>Color distance is non-negative: d(a,b) \u2265 0</li> <li>HSL\u2192RGB\u2192HSL roundtrip (within floating point tolerance)</li> </ul>"},{"location":"ARCHITECTURE/#open-questions-for-implementation","title":"Open Questions for Implementation","text":"<ol> <li>CSG Library:</li> <li>Java uses JCSG library</li> <li>Rust: Implement basic mesh operations or find crate?</li> <li> <p>Decision: Start with manual triangle mesh generation</p> </li> <li> <p>Parallel Processing Granularity:</p> </li> <li>Java uses thread pools at multiple levels</li> <li>Rust: Rely on rayon's work-stealing?</li> <li> <p>Decision: Use rayon throughout, profile if needed</p> </li> <li> <p>Memory Management:</p> </li> <li>Java has \"low memory\" mode with temp files</li> <li>Rust: Rely on ownership system?</li> <li> <p>Decision: Implement if profiling shows issues</p> </li> <li> <p>Error Handling Strategy:</p> </li> <li>Java uses checked exceptions</li> <li>Rust: <code>Result&lt;T, Error&gt;</code> everywhere</li> <li>Decision: Use <code>anyhow</code> for application, <code>thiserror</code> for library</li> </ol>"},{"location":"ARCHITECTURE/#references","title":"References","text":"<ul> <li>Original PIXEstL: https://github.com/gaugo87/PIXEstL</li> <li>JCSG Library: https://github.com/miho/JCSG</li> <li>CIE76 Delta E: https://en.wikipedia.org/wiki/Color_difference#CIE76</li> <li>STL Format: https://en.wikipedia.org/wiki/STL_(file_format)</li> </ul>"},{"location":"IMPLEMENTATION_PLAN/","title":"PIXEstL Rust Implementation Plan","text":""},{"location":"IMPLEMENTATION_PLAN/#project-goals","title":"Project Goals","text":"<ol> <li>Complete Feature Parity: Rust version must produce identical output to Java version</li> <li>Performance: Match or exceed Java performance</li> <li>Code Quality: Idiomatic Rust with comprehensive tests</li> <li>Documentation: Full API documentation and usage guides</li> <li>Maintainability: Clean architecture following Rust best practices</li> </ol>"},{"location":"IMPLEMENTATION_PLAN/#implementation-strategy","title":"Implementation Strategy","text":""},{"location":"IMPLEMENTATION_PLAN/#approach-incremental-bottom-up-development","title":"Approach: Incremental Bottom-Up Development","text":"<p>We'll build from foundational modules upward, testing each layer before proceeding. This ensures: - Early validation of core algorithms - Easier debugging - Modular development with clear milestones</p>"},{"location":"IMPLEMENTATION_PLAN/#success-criteria-per-phase","title":"Success Criteria Per Phase","text":"<p>Each phase must meet these before proceeding: - \u2705 All unit tests pass - \u2705 Code compiles without warnings (<code>cargo clippy</code>) - \u2705 Formatted correctly (<code>cargo fmt</code>) - \u2705 Documentation complete (<code>cargo doc</code>) - \u2705 Benchmarks (where applicable) meet targets</p>"},{"location":"IMPLEMENTATION_PLAN/#phase-1-foundation-infrastructure","title":"Phase 1: Foundation &amp; Infrastructure","text":"<p>Duration Estimate: 1-2 days Complexity: Low</p>"},{"location":"IMPLEMENTATION_PLAN/#milestone-11-project-setup","title":"Milestone 1.1: Project Setup","text":"<p>Tasks: 1. Initialize Rust project with Cargo 2. Configure <code>Cargo.toml</code> with all dependencies 3. Set up project structure (all directories and module files) 4. Create placeholder modules with empty implementations 5. Set up basic error types</p> <p>Deliverables: - <code>Cargo.toml</code> with dependencies - Directory structure matching architecture - Compiling (but non-functional) project - <code>src/error.rs</code> with main error types</p> <p>Validation: <pre><code>cargo build\ncargo clippy\ncargo fmt -- --check\n</code></pre></p>"},{"location":"IMPLEMENTATION_PLAN/#milestone-12-error-handling","title":"Milestone 1.2: Error Handling","text":"<p>Tasks: 1. Define comprehensive error types using <code>thiserror</code> 2. Implement error conversions 3. Add unit tests for error propagation</p> <p>Deliverables: - <code>src/error.rs</code> complete - Error types for: IO, ImageLoad, PaletteParse, Config, StlGeneration - Result type alias: <code>pub type Result&lt;T&gt; = std::result::Result&lt;T, PixestlError&gt;</code></p> <p>Test Coverage: - Error conversion from external crates - Error display messages</p>"},{"location":"IMPLEMENTATION_PLAN/#phase-2-color-processing-core","title":"Phase 2: Color Processing Core","text":"<p>Duration Estimate: 3-4 days Complexity: Medium-High (Math-heavy)</p>"},{"location":"IMPLEMENTATION_PLAN/#milestone-21-rgb-color-type","title":"Milestone 2.1: RGB Color Type","text":"<p>Tasks: 1. Implement <code>Rgb</code> struct with u8 components 2. Add conversions: from/to hex string 3. Basic operations: equality, debug formatting 4. Unit tests with known values</p> <p>Deliverables: - <code>src/color/rgb.rs</code> - Tests: hex parsing, round-trip conversions</p> <p>Key Implementation: <pre><code>#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\npub struct Rgb {\n    pub r: u8,\n    pub g: u8,\n    pub b: u8,\n}\n\nimpl Rgb {\n    pub fn new(r: u8, g: u8, b: u8) -&gt; Self { ... }\n    pub fn from_hex(hex: &amp;str) -&gt; Result&lt;Self&gt; { ... }\n    pub fn to_hex(&amp;self) -&gt; String { ... }\n}\n</code></pre></p>"},{"location":"IMPLEMENTATION_PLAN/#milestone-22-hsl-color-space","title":"Milestone 2.2: HSL Color Space","text":"<p>Tasks: 1. Implement <code>Hsl</code> struct with f64 components 2. RGB \u2192 HSL conversion 3. HSL \u2192 RGB conversion 4. Unit tests with reference values</p> <p>Deliverables: - <code>src/color/hsl.rs</code> - Tests: conversion accuracy (known test vectors)</p> <p>Algorithm Source: Java ColorUtil.colorToHSL, hueToRgb</p> <p>Critical Test Cases: - Pure colors (red, green, blue) - Grayscale (R=G=B) - Edge cases (H wrap-around at 360\u00b0)</p>"},{"location":"IMPLEMENTATION_PLAN/#milestone-23-cielab-color-space","title":"Milestone 2.3: CIELab Color Space","text":"<p>Tasks: 1. Implement <code>CieLab</code> struct 2. RGB \u2192 XYZ conversion (D65 illuminant) 3. XYZ \u2192 CIELab conversion 4. Delta E (CIE76) distance calculation 5. Comprehensive unit tests</p> <p>Deliverables: - <code>src/color/cielab.rs</code> - Tests: standard color conversions, Delta E symmetry</p> <p>Algorithm Source: Java ColorUtil.rgbToXyz, xyzToLab, deltaE</p> <p>Critical Test Cases: - White (L=100, a=0, b=0) - Black (L=0, a\u22480, b\u22480) - Distance symmetry: d(a,b) = d(b,a) - Distance non-negativity: d(a,b) \u2265 0 - Same color: d(a,a) = 0</p>"},{"location":"IMPLEMENTATION_PLAN/#milestone-24-cmyk-support","title":"Milestone 2.4: CMYK Support","text":"<p>Tasks: 1. Implement CMYK struct 2. HSL \u2192 CMYK conversion 3. CMYK \u2192 RGB conversion 4. Unit tests</p> <p>Deliverables: - <code>src/color/cmyk.rs</code> (or in rgb.rs) - Tests: conversion round-trips</p> <p>Usage: Required for additive color mixing in ColorCombi</p>"},{"location":"IMPLEMENTATION_PLAN/#milestone-25-color-distance-trait","title":"Milestone 2.5: Color Distance Trait","text":"<p>Tasks: 1. Define <code>ColorDistance</code> trait 2. Implement for RGB (Euclidean) 3. Implement for CIELab (Delta E) 4. Benchmarks comparing both methods</p> <p>Deliverables: - <code>src/color/distance.rs</code> - Property-based tests (using <code>proptest</code> crate)</p> <p>Trait Definition: <pre><code>pub trait ColorDistance {\n    fn distance(&amp;self, other: &amp;Self) -&gt; f64;\n}\n\nimpl ColorDistance for Rgb { ... }\nimpl ColorDistance for CieLab { ... }\n</code></pre></p> <p>Benchmarks: - 1,000 color comparisons - RGB vs CIELab performance</p>"},{"location":"IMPLEMENTATION_PLAN/#phase-3-palette-system","title":"Phase 3: Palette System","text":"<p>Duration Estimate: 3-4 days Complexity: High (Complex data structures)</p>"},{"location":"IMPLEMENTATION_PLAN/#milestone-31-data-structures","title":"Milestone 3.1: Data Structures","text":"<p>Tasks: 1. Define <code>ColorLayer</code> struct 2. Define <code>ColorCombi</code> struct 3. Define <code>Filament</code> struct 4. Implement builders/constructors</p> <p>Deliverables: - <code>src/palette/layer.rs</code> - <code>src/palette/filament.rs</code> - Basic creation and access methods</p> <p>Structures: <pre><code>pub struct ColorLayer {\n    hex_code: String,\n    layer: u32,\n    c: f64, m: f64, y: f64, k: f64,\n}\n\npub struct ColorCombi {\n    layers: Vec&lt;ColorLayer&gt;,\n    cached_color: Option&lt;Rgb&gt;,\n}\n\npub struct Filament {\n    hex_code: String,\n    name: String,\n    active: bool,\n    layers: HashMap&lt;u32, ColorLayer&gt;,\n}\n</code></pre></p>"},{"location":"IMPLEMENTATION_PLAN/#milestone-32-json-palette-loading","title":"Milestone 3.2: JSON Palette Loading","text":"<p>Tasks: 1. Define JSON schema with <code>serde</code> 2. Implement palette file parser 3. Handle hex code or HSL layer values 4. Validation (required fields, #FFFFFF check) 5. Unit tests with example palette</p> <p>Deliverables: - <code>src/palette/loader.rs</code> - Tests: valid/invalid JSON, error handling</p> <p>Validation Rules: - <code>#FFFFFF</code> must exist in ADDITIVE mode - HSL values in valid ranges - Hex codes are valid format</p>"},{"location":"IMPLEMENTATION_PLAN/#milestone-33-colorcombi-generation-algorithm","title":"Milestone 3.3: ColorCombi Generation Algorithm","text":"<p>Tasks: 1. Implement recursive combination generator 2. Handle ADDITIVE mode (no duplicate colors) 3. Handle FULL mode (single color per pixel) 4. Factorize adjacent same-color layers 5. Unit tests with small palettes</p> <p>Deliverables: - <code>src/palette/mod.rs</code> - main algorithm - Tests: count of combinations, correctness</p> <p>Algorithm Complexity: - Exponential but pruned (early exit) - Test with 3-color palette \u2192 verify count - Test with real palette \u2192 check performance</p> <p>Critical Tests: - 2 colors, 5 layers \u2192 count combinations - Verify no duplicate colors in combination (ADDITIVE) - Verify sum of layers equals target</p>"},{"location":"IMPLEMENTATION_PLAN/#milestone-34-color-quantization","title":"Milestone 3.4: Color Quantization","text":"<p>Tasks: 1. Implement parallel color matching 2. Use Rayon for pixel iteration 3. Handle transparency 4. Return quantized image</p> <p>Deliverables: - <code>src/palette/mod.rs</code> - quantize function - Benchmark: 1000x1000 image quantization</p> <p>Algorithm: <pre><code>pub fn quantize_colors(\n    image: &amp;RgbaImage,\n    combis: &amp;[ColorCombi],\n    method: ColorDistanceMethod,\n) -&gt; RgbaImage {\n    let width = image.width();\n    let height = image.height();\n\n    let pixels: Vec&lt;_&gt; = (0..height)\n        .into_par_iter()\n        .flat_map(|y| {\n            (0..width).map(move |x| {\n                let pixel = image.get_pixel(x, y);\n                if pixel[3] == 0 { return (x, y, *pixel); }\n\n                let color = Rgb::new(pixel[0], pixel[1], pixel[2]);\n                let closest = find_closest_color(&amp;color, combis, method);\n                (x, y, Rgba([closest.r, closest.g, closest.b, 255]))\n            })\n        })\n        .collect();\n\n    // Construct result image from pixels\n    ...\n}\n</code></pre></p>"},{"location":"IMPLEMENTATION_PLAN/#phase-4-image-processing","title":"Phase 4: Image Processing","text":"<p>Duration Estimate: 2-3 days Complexity: Medium</p>"},{"location":"IMPLEMENTATION_PLAN/#milestone-41-image-loading-basic-operations","title":"Milestone 4.1: Image Loading &amp; Basic Operations","text":"<p>Tasks: 1. Load images using <code>image</code> crate 2. Implement resize with aspect ratio preservation 3. Image flipping (vertical mirror) 4. Transparency detection</p> <p>Deliverables: - <code>src/image/loader.rs</code> - Tests: load different formats (PNG, JPG), resize accuracy</p> <p>Key Functions: <pre><code>pub fn load_image(path: &amp;Path) -&gt; Result&lt;RgbaImage&gt;;\npub fn resize_image(image: &amp;RgbaImage, width_mm: Option&lt;f64&gt;,\n                    height_mm: Option&lt;f64&gt;, pixel_size_mm: f64) -&gt; RgbaImage;\npub fn flip_vertical(image: &amp;RgbaImage) -&gt; RgbaImage;\npub fn has_transparency(image: &amp;RgbaImage) -&gt; bool;\n</code></pre></p>"},{"location":"IMPLEMENTATION_PLAN/#milestone-42-grayscale-conversion","title":"Milestone 4.2: Grayscale Conversion","text":"<p>Tasks: 1. Implement luminance formula (BT.709) 2. Handle transparency in grayscale 3. Unit tests with known values</p> <p>Deliverables: - <code>src/image/processor.rs</code> - Tests: luminance calculation</p> <p>Formula: <pre><code>L = 0.2126 * R + 0.7152 * G + 0.0722 * B\n</code></pre></p> <p>Test Cases: - Pure white (255,255,255) \u2192 255 - Pure black (0,0,0) \u2192 0 - Pure red (255,0,0) \u2192 54</p>"},{"location":"IMPLEMENTATION_PLAN/#phase-5-3d-geometry-mesh-generation","title":"Phase 5: 3D Geometry &amp; Mesh Generation","text":"<p>Duration Estimate: 4-5 days Complexity: High</p>"},{"location":"IMPLEMENTATION_PLAN/#milestone-51-basic-mesh-structures","title":"Milestone 5.1: Basic Mesh Structures","text":"<p>Tasks: 1. Define <code>Vertex</code> type (3D point) 2. Define <code>Triangle</code> type (3 vertices + normal) 3. Define <code>Mesh</code> type (collection of triangles) 4. Basic mesh operations (add triangle, calculate bounds)</p> <p>Deliverables: - <code>src/geometry/mesh.rs</code> - <code>src/geometry/triangle.rs</code> - Tests: basic operations</p> <p>Structures: <pre><code>pub struct Vertex {\n    pub x: f64,\n    pub y: f64,\n    pub z: f64,\n}\n\npub struct Triangle {\n    pub vertices: [Vertex; 3],\n    pub normal: Vertex,\n}\n\npub struct Mesh {\n    pub triangles: Vec&lt;Triangle&gt;,\n}\n</code></pre></p>"},{"location":"IMPLEMENTATION_PLAN/#milestone-52-cuboid-primitive","title":"Milestone 5.2: Cuboid Primitive","text":"<p>Tasks: 1. Generate cuboid at position (x, y, z) 2. Parameterize width, height, depth 3. Generate 12 triangles (2 per face) 4. Calculate normals</p> <p>Deliverables: - <code>src/geometry/primitives.rs</code> - Tests: vertex count, normal directions</p> <p>Usage: Foundation for pixel cuboids in color layers</p>"},{"location":"IMPLEMENTATION_PLAN/#milestone-53-heightmap-to-mesh","title":"Milestone 5.3: Heightmap to Mesh","text":"<p>Tasks: 1. Accept 2D array of heights 2. Generate mesh with varying Z values 3. Handle transparency (skip pixels) 4. Optimize for STL export</p> <p>Deliverables: - <code>src/geometry/heightmap.rs</code> - Tests: small heightmap \u2192 verify triangles</p> <p>Algorithm: For each pixel (x, y) with height h: - Create top face at Z = h - Create side faces to adjacent pixels - Skip if transparent</p>"},{"location":"IMPLEMENTATION_PLAN/#milestone-54-stl-binary-writer","title":"Milestone 5.4: STL Binary Writer","text":"<p>Tasks: 1. Use <code>stl_io</code> crate or manual implementation 2. Write binary STL format 3. Correct byte ordering (little-endian) 4. Add unit tests with reference files</p> <p>Deliverables: - <code>src/stl/writer.rs</code> - <code>src/stl/binary.rs</code> - Tests: write mesh, verify file structure</p> <p>STL Binary Format: - 80-byte header - 4-byte triangle count (u32) - Per triangle: normal (3\u00d7f32), vertices (3\u00d73\u00d7f32), attribute (u16)</p>"},{"location":"IMPLEMENTATION_PLAN/#phase-6-lithophane-generation-logic","title":"Phase 6: Lithophane Generation Logic","text":"<p>Duration Estimate: 4-5 days Complexity: High</p>"},{"location":"IMPLEMENTATION_PLAN/#milestone-61-color-layer-generation","title":"Milestone 6.1: Color Layer Generation","text":"<p>Tasks: 1. For each unique color in palette:    - Iterate over quantized image    - For each pixel with this color:      - Get ColorCombi      - Find layers for this color in combo      - Create cuboid at (x, y) with appropriate Z-offset and thickness 2. Combine all cuboids into single mesh 3. Handle multiple layer groups (AMS mode)</p> <p>Deliverables: - <code>src/lithophane/color_layer.rs</code> - Tests: small test image \u2192 verify cuboid count</p> <p>Algorithm Outline: <pre><code>pub fn generate_color_layer(\n    image: &amp;RgbaImage,\n    palette: &amp;Palette,\n    hex_code: &amp;str,\n    config: &amp;Config,\n) -&gt; Mesh {\n    let mut mesh = Mesh::new();\n\n    for y in 0..image.height() {\n        for x in 0..image.width() {\n            let pixel = image.get_pixel(x, y);\n            if pixel[3] == 0 { continue; }\n\n            let color = Rgb::new(pixel[0], pixel[1], pixel[2]);\n            let combi = palette.get_combi(&amp;color);\n\n            if let Some(layer_thickness) = combi.thickness_for_color(hex_code) {\n                let z_offset = combi.z_offset_for_color(hex_code);\n                let cuboid = create_cuboid(\n                    x as f64 * config.color_pixel_width,\n                    y as f64 * config.color_pixel_width,\n                    z_offset,\n                    config.color_pixel_width,\n                    config.color_pixel_width,\n                    layer_thickness,\n                );\n                mesh.add_triangles(cuboid.triangles);\n            }\n        }\n    }\n\n    mesh\n}\n</code></pre></p>"},{"location":"IMPLEMENTATION_PLAN/#milestone-62-texture-layer-generation","title":"Milestone 6.2: Texture Layer Generation","text":"<p>Tasks: 1. Iterate over grayscale image 2. Map luminance to height (min_thickness to max_thickness) 3. Generate heightmap 4. Convert heightmap to mesh 5. Handle transparency</p> <p>Deliverables: - <code>src/lithophane/texture_layer.rs</code> - Tests: gradient image \u2192 verify heights</p> <p>Height Mapping: <pre><code>let height = config.texture_min_thickness +\n    (luminance as f64 / 255.0) *\n    (config.texture_max_thickness - config.texture_min_thickness);\n</code></pre></p>"},{"location":"IMPLEMENTATION_PLAN/#milestone-63-support-plate-generation","title":"Milestone 6.3: Support Plate Generation","text":"<p>Tasks: 1. Generate flat plate at Z=0 2. Thickness = config.plate_thickness 3. Handle transparency (create holes) 4. Fast generation (simple rectangle or complex with holes)</p> <p>Deliverables: - <code>src/lithophane/plate.rs</code> - Tests: with/without transparency</p> <p>Two Modes: - No transparency: Single large cuboid (fast) - With transparency: Per-pixel cuboids with holes</p>"},{"location":"IMPLEMENTATION_PLAN/#milestone-64-main-generator-orchestration","title":"Milestone 6.4: Main Generator Orchestration","text":"<p>Tasks: 1. Implement main <code>LithophaneGenerator</code> struct 2. Coordinate all layer generation 3. Handle parallelization (Rayon) 4. Progress reporting (optional)</p> <p>Deliverables: - <code>src/lithophane/generator.rs</code> - Integration test: small end-to-end example</p> <p>Structure: <pre><code>pub struct LithophaneGenerator {\n    config: Config,\n    palette: Palette,\n}\n\nimpl LithophaneGenerator {\n    pub fn generate(&amp;self, image_path: &amp;Path) -&gt; Result&lt;GeneratedLayers&gt; {\n        // 1. Load and process image\n        // 2. Quantize colors\n        // 3. Generate color layers (parallel)\n        // 4. Generate texture layer\n        // 5. Generate support plate\n        // Return all meshes\n    }\n}\n</code></pre></p>"},{"location":"IMPLEMENTATION_PLAN/#phase-7-cli-interface","title":"Phase 7: CLI Interface","text":"<p>Duration Estimate: 2 days Complexity: Medium</p>"},{"location":"IMPLEMENTATION_PLAN/#milestone-71-argument-parsing","title":"Milestone 7.1: Argument Parsing","text":"<p>Tasks: 1. Define CLI arguments using <code>clap</code> derive macros 2. Match all Java CLI arguments exactly 3. Add validation 4. Help text and examples</p> <p>Deliverables: - <code>src/cli.rs</code> - Tests: parse valid/invalid arguments</p> <p>Argument Structure: <pre><code>#[derive(Parser, Debug)]\n#[command(name = \"pixestl\")]\n#[command(about = \"Color lithophane generator for 3D printing\")]\npub struct Args {\n    #[arg(short = 'i', long)]\n    pub src_image_path: PathBuf,\n\n    #[arg(short = 'p', long)]\n    pub palette_path: PathBuf,\n\n    // ... all other arguments matching Java version\n}\n</code></pre></p>"},{"location":"IMPLEMENTATION_PLAN/#milestone-72-configuration-builder","title":"Milestone 7.2: Configuration Builder","text":"<p>Tasks: 1. Convert CLI args to <code>Config</code> struct 2. Apply defaults 3. Validate combinations (e.g., width or height required) 4. Comprehensive unit tests</p> <p>Deliverables: - <code>src/config.rs</code> - Tests: default values, validation</p>"},{"location":"IMPLEMENTATION_PLAN/#phase-8-output-packaging","title":"Phase 8: Output &amp; Packaging","text":"<p>Duration Estimate: 2 days Complexity: Low-Medium</p>"},{"location":"IMPLEMENTATION_PLAN/#milestone-81-stl-export","title":"Milestone 8.1: STL Export","text":"<p>Tasks: 1. Write each mesh to STL file 2. Use parallel writing if beneficial 3. Progress indicators</p> <p>Deliverables: - <code>src/output/exporter.rs</code> - Tests: verify STL files loadable in external tools</p>"},{"location":"IMPLEMENTATION_PLAN/#milestone-82-zip-archive-creation","title":"Milestone 8.2: ZIP Archive Creation","text":"<p>Tasks: 1. Create ZIP using <code>zip</code> crate 2. Add all STL files 3. Add preview PNG images 4. Add instructions.txt (for AMS mode)</p> <p>Deliverables: - <code>src/output/exporter.rs</code> (extend) - Tests: verify ZIP contents</p> <p>ZIP Contents: - <code>layer-&lt;color&gt;.stl</code> (per color) - <code>layer-plate.stl</code> - <code>layer-texture-&lt;color&gt;.stl</code> - <code>image-color-preview.png</code> - <code>image-texture-preview.png</code> - <code>instructions.txt</code> (if colorNumber set)</p>"},{"location":"IMPLEMENTATION_PLAN/#milestone-83-preview-image-generation","title":"Milestone 8.3: Preview Image Generation","text":"<p>Tasks: 1. Save quantized color image as PNG 2. Save grayscale texture image as PNG 3. Use <code>image</code> crate for PNG encoding</p> <p>Deliverables: - <code>src/output/preview.rs</code> - Tests: verify PNG files created</p>"},{"location":"IMPLEMENTATION_PLAN/#phase-9-testing-quality-assurance","title":"Phase 9: Testing &amp; Quality Assurance","text":"<p>Duration Estimate: 3-4 days Complexity: Medium</p>"},{"location":"IMPLEMENTATION_PLAN/#milestone-91-unit-test-completion","title":"Milestone 9.1: Unit Test Completion","text":"<p>Tasks: 1. Ensure every module has &gt;80% coverage 2. Add missing edge case tests 3. Property-based tests for math functions</p> <p>Deliverables: - Tests passing: <code>cargo test</code> - Coverage report (using <code>tarpaulin</code> or similar)</p> <p>Critical Modules: - Color conversions (most important!) - Palette combinatorics - Mesh generation</p>"},{"location":"IMPLEMENTATION_PLAN/#milestone-92-integration-tests","title":"Milestone 9.2: Integration Tests","text":"<p>Tasks: 1. End-to-end test with small test image 2. Verify output ZIP structure 3. Compare with Java output (manually)</p> <p>Deliverables: - <code>tests/integration/</code> directory - Test fixtures in <code>tests/fixtures/</code></p> <p>Test Images: - 10x10 solid color - 10x10 gradient - 10x10 with transparency - Small version of example image</p>"},{"location":"IMPLEMENTATION_PLAN/#milestone-93-benchmark-suite","title":"Milestone 9.3: Benchmark Suite","text":"<p>Tasks: 1. Benchmark color distance calculations 2. Benchmark image quantization 3. Benchmark mesh generation 4. Compare with Java timings</p> <p>Deliverables: - <code>benches/benchmarks.rs</code> - Performance report</p> <p>Targets: - 100x100 image: &lt; 1 second - 1000x1000 image: &lt; 30 seconds</p>"},{"location":"IMPLEMENTATION_PLAN/#milestone-94-validation-against-java","title":"Milestone 9.4: Validation Against Java","text":"<p>Tasks: 1. Run same inputs through both versions 2. Compare quantized images (pixel-perfect match expected) 3. Compare STL vertex counts (within tolerance) 4. Compare color layer assignments</p> <p>Deliverables: - Validation script or test - Report of any differences</p> <p>Acceptance Criteria: - Quantized images: Identical - STL sizes: Within 1% (floating point differences acceptable) - Processing time: Rust \u2264 Java</p>"},{"location":"IMPLEMENTATION_PLAN/#phase-10-documentation-polish","title":"Phase 10: Documentation &amp; Polish","text":"<p>Duration Estimate: 2-3 days Complexity: Low</p>"},{"location":"IMPLEMENTATION_PLAN/#milestone-101-api-documentation","title":"Milestone 10.1: API Documentation","text":"<p>Tasks: 1. Add <code>///</code> doc comments to all public items 2. Add examples to complex functions 3. Generate with <code>cargo doc --no-deps</code> 4. Review for completeness</p> <p>Deliverables: - Complete rustdoc - Examples in docstrings</p>"},{"location":"IMPLEMENTATION_PLAN/#milestone-102-user-documentation","title":"Milestone 10.2: User Documentation","text":"<p>Tasks: 1. Write comprehensive README.md 2. Usage examples 3. Installation instructions 4. Comparison with Java version</p> <p>Deliverables: - <code>README.md</code> in project root - <code>docs/USAGE.md</code></p>"},{"location":"IMPLEMENTATION_PLAN/#milestone-103-code-quality-audit","title":"Milestone 10.3: Code Quality Audit","text":"<p>Tasks: 1. Run <code>cargo clippy</code> - fix all warnings 2. Run <code>cargo fmt</code> - ensure consistent style 3. Review <code>unsafe</code> blocks (should be none) 4. Review error handling (no <code>unwrap</code> in library code)</p> <p>Deliverables: - Clean <code>clippy</code> output - Formatted codebase</p>"},{"location":"IMPLEMENTATION_PLAN/#phase-11-cicd-release-preparation","title":"Phase 11: CI/CD &amp; Release Preparation","text":"<p>Duration Estimate: 1-2 days Complexity: Low</p>"},{"location":"IMPLEMENTATION_PLAN/#milestone-111-github-actions","title":"Milestone 11.1: GitHub Actions","text":"<p>Tasks: 1. Create <code>.github/workflows/ci.yml</code> 2. Run tests on push/PR 3. Build on multiple platforms (Linux, Windows, macOS) 4. Run clippy and format checks</p> <p>Deliverables: - Working CI pipeline</p>"},{"location":"IMPLEMENTATION_PLAN/#milestone-112-release-binary-builds","title":"Milestone 11.2: Release Binary Builds","text":"<p>Tasks: 1. Set up release workflow 2. Cross-compile for major platforms 3. Create GitHub releases with binaries</p> <p>Deliverables: - Automated release process</p>"},{"location":"IMPLEMENTATION_PLAN/#risk-assessment-mitigation","title":"Risk Assessment &amp; Mitigation","text":""},{"location":"IMPLEMENTATION_PLAN/#high-risk-areas","title":"High-Risk Areas","text":"Risk Probability Impact Mitigation CIELab conversion errors Medium High Extensive unit tests with reference values ColorCombi explosion Low High Add limit checks, test with real palettes Mesh generation bugs Medium High Incremental testing, visualization tools Performance &lt; Java Low Medium Profile early, optimize hot paths with SIMD Platform compatibility Low Low CI on all platforms, integration tests"},{"location":"IMPLEMENTATION_PLAN/#medium-risk-areas","title":"Medium-Risk Areas","text":"Risk Probability Impact Mitigation Floating point precision Medium Medium Use epsilon comparisons in tests Memory usage on large images Low Medium Profile, optimize, use streaming if needed Palette JSON edge cases Medium Low Fuzz testing, manual review of format"},{"location":"IMPLEMENTATION_PLAN/#development-best-practices","title":"Development Best Practices","text":""},{"location":"IMPLEMENTATION_PLAN/#code-style","title":"Code Style","text":"<ul> <li>Follow Rust API guidelines</li> <li>Use <code>clippy::pedantic</code> for extra checks</li> <li>Prefer immutability and owned types</li> <li>Use <code>&amp;str</code> for string parameters, <code>String</code> for returns</li> </ul>"},{"location":"IMPLEMENTATION_PLAN/#testing-strategy","title":"Testing Strategy","text":"<ol> <li>TDD for Algorithms: Write tests before implementing complex logic</li> <li>Fast Tests: Unit tests should run in &lt;1s total</li> <li>Integration Tests: Separate from unit tests, can be slower</li> <li>Benchmarks: Run separately, track over time</li> </ol>"},{"location":"IMPLEMENTATION_PLAN/#error-handling","title":"Error Handling","text":"<ul> <li>Use <code>Result&lt;T, PixestlError&gt;</code> throughout</li> <li>Provide context with <code>.context()</code> from <code>anyhow</code></li> <li>Never <code>panic!</code> in library code</li> <li>Only <code>unwrap()</code> when mathematically impossible to fail</li> </ul>"},{"location":"IMPLEMENTATION_PLAN/#performance","title":"Performance","text":"<ul> <li>Profile before optimizing (use <code>cargo flamegraph</code>)</li> <li>Start with simple, correct code</li> <li>Optimize hot paths after profiling</li> <li>Consider SIMD only if measurements show benefit</li> </ul>"},{"location":"IMPLEMENTATION_PLAN/#documentation","title":"Documentation","text":"<ul> <li>All public items must have doc comments</li> <li>Add examples for complex functions</li> <li>Link to related items with <code>[</code>Module<code>]</code> syntax</li> <li>Reference Java implementation in comments where useful</li> </ul>"},{"location":"IMPLEMENTATION_PLAN/#milestones-summary","title":"Milestones Summary","text":"Phase Milestones Duration Dependencies 1. Foundation 1.1-1.2 1-2 days None 2. Color 2.1-2.5 3-4 days Phase 1 3. Palette 3.1-3.4 3-4 days Phase 2 4. Image 4.1-4.2 2-3 days Phase 2 5. Geometry 5.1-5.4 4-5 days Phase 1 6. Generator 6.1-6.4 4-5 days Phases 3, 4, 5 7. CLI 7.1-7.2 2 days Phase 6 8. Output 8.1-8.3 2 days Phase 5, 6 9. Testing 9.1-9.4 3-4 days All phases 10. Docs 10.1-10.3 2-3 days All phases 11. CI/CD 11.1-11.2 1-2 days Phase 9 <p>Total Estimated Duration: 27-37 days</p> <p>Critical Path: Phase 1 \u2192 2 \u2192 3 \u2192 6 \u2192 7 \u2192 8 \u2192 9</p>"},{"location":"IMPLEMENTATION_PLAN/#success-metrics","title":"Success Metrics","text":""},{"location":"IMPLEMENTATION_PLAN/#functional","title":"Functional","text":"<ul> <li>\u2705 All CLI arguments from Java version supported</li> <li>\u2705 Same palette JSON format accepted</li> <li>\u2705 Identical quantized image output</li> <li>\u2705 STL files loadable in slicer software</li> <li>\u2705 ZIP contains all expected files</li> </ul>"},{"location":"IMPLEMENTATION_PLAN/#quality","title":"Quality","text":"<ul> <li>\u2705 80%+ code coverage</li> <li>\u2705 Zero clippy warnings</li> <li>\u2705 All tests pass on Linux, Windows, macOS</li> <li>\u2705 Complete rustdoc for public API</li> </ul>"},{"location":"IMPLEMENTATION_PLAN/#performance_1","title":"Performance","text":"<ul> <li>\u2705 100x100 image: &lt; 1s</li> <li>\u2705 1000x1000 image: &lt; 30s</li> <li>\u2705 Memory usage: &lt; 500MB for typical images</li> </ul>"},{"location":"IMPLEMENTATION_PLAN/#next-steps","title":"Next Steps","text":"<p>After reading this plan: 1. Setup Phase 1: Initialize Rust project 2. Create Skeleton: All module files with empty impls 3. Start Phase 2: Begin with color modules (most critical)</p> <p>Ready to begin implementation!</p>"},{"location":"cli-referenz/","title":"CLI-Referenz","text":"<p>Vollstaendige Referenz aller Kommandozeilen-Parameter von PIXEstL.</p>"},{"location":"cli-referenz/#syntax","title":"Syntax","text":"<pre><code>pixestl [OPTIONEN] -i &lt;DATEI&gt; -p &lt;DATEI&gt; -o &lt;DATEI&gt;\npixestl --calibrate -p &lt;DATEI&gt; -o &lt;DATEI&gt;\npixestl --palette-info -p &lt;DATEI&gt;\n</code></pre>"},{"location":"cli-referenz/#pflichtparameter","title":"Pflichtparameter","text":"<p>Diese Parameter sind beim regulaeren Lithophanie-Aufruf erforderlich:</p> Parameter Kurzform Beschreibung <code>--input</code> <code>-i</code> Pfad zum Eingabebild (JPG, PNG, WebP). Nicht noetig bei <code>--calibrate</code> oder <code>--palette-info</code>. <code>--palette</code> <code>-p</code> Pfad zur Palette-Datei (JSON) <code>--output</code> <code>-o</code> Pfad zur Ausgabe-Datei (ZIP mit STL-Dateien). Nicht noetig bei <code>--palette-info</code>. <p>Minimalbeispiel</p> <pre><code>pixestl -i foto.jpg -p palette/filament-palette-0.10mm.json -o ausgabe.zip\n</code></pre>"},{"location":"cli-referenz/#bildgroesse","title":"Bildgroesse","text":"<p>Steuert die physische Groesse der Lithophanie in Millimetern.</p> Parameter Kurzform Standard Beschreibung <code>--width</code> <code>-w</code> <code>0</code> Breite der Lithophanie in mm <code>--height</code> <code>-H</code> <code>0</code> Hoehe der Lithophanie in mm <p>Automatische Groesse</p> <p>Der Wert <code>0</code> bedeutet automatisch: Die jeweilige Dimension wird proportional zur anderen berechnet. Wird nur <code>--width 100</code> angegeben, ergibt sich die Hoehe automatisch aus dem Seitenverhaeltnis des Bildes.</p> <p>Beispiele</p> <pre><code># Breite 100mm, Hoehe automatisch (proportional)\npixestl -i foto.jpg -p palette.json -o out.zip -w 100\n\n# Hoehe 80mm, Breite automatisch (proportional)\npixestl -i foto.jpg -p palette.json -o out.zip -H 80\n\n# Exakte Groesse 100x80mm (kann verzerren)\npixestl -i foto.jpg -p palette.json -o out.zip -w 100 -H 80\n</code></pre>"},{"location":"cli-referenz/#farbschicht-einstellungen","title":"Farbschicht-Einstellungen","text":"<p>Parameter fuer die CMYK-Farbschichten.</p> Parameter Standard Beschreibung <code>--color-pixel-width</code> <code>0.8</code> Breite eines Farbpixels in mm <code>--color-layer-thickness</code> <code>0.1</code> Dicke einer einzelnen Farbschicht in mm <code>--color-layers</code> <code>5</code> Anzahl der Farbschichten pro Pixel <code>--no-color</code> - Farbschichten deaktivieren (nur Textur generieren) <p>Pixelbreite und Aufloesung</p> <p>Die <code>--color-pixel-width</code> bestimmt die Aufloesung der Farbschicht. Kleinere Werte erzeugen mehr Details, aber auch groessere STL-Dateien und laengere Druckzeiten. Der Standardwert von 0.8mm bietet einen guten Kompromiss.</p> <p>Schichtdicke</p> <p>Die <code>--color-layer-thickness</code> sollte mit der Schichthoehe im Slicer uebereinstimmen. Fuer 0.10mm-Druckprofile den Standardwert <code>0.1</code> verwenden.</p> <p>Nur Graustufen (ohne Farbschicht)</p> <pre><code>pixestl -i foto.jpg -p palette.json -o out.zip -w 100 --no-color\n</code></pre>"},{"location":"cli-referenz/#texturschicht-einstellungen","title":"Texturschicht-Einstellungen","text":"<p>Parameter fuer die Texturschicht (Helligkeitsrelief).</p> Parameter Standard Beschreibung <code>--texture-pixel-width</code> <code>0.25</code> Breite eines Texturpixels in mm <code>--texture-min</code> <code>0.3</code> Minimale Texturdicke in mm (hellster Punkt) <code>--texture-max</code> <code>1.8</code> Maximale Texturdicke in mm (dunkelster Punkt) <code>--no-texture</code> - Texturschicht deaktivieren (nur Farbe generieren) <p>Texturschicht erklaert</p> <p>Die Texturschicht erzeugt das klassische Lithophanie-Relief: Dunkle Bereiche sind dicker (weniger Lichtdurchlass), helle Bereiche duenner. Sie verleiht dem Bild Tiefe und Kontrast, unabhaengig von der Farbschicht.</p> <p>Nur Farbe (ohne Texturschicht)</p> <pre><code>pixestl -i foto.jpg -p palette.json -o out.zip -w 100 --no-texture\n</code></pre>"},{"location":"cli-referenz/#export-optionen","title":"Export-Optionen","text":"<p>Parameter fuer die STL-Ausgabe.</p> Parameter Standard Beschreibung <code>--format</code> <code>ascii</code> STL-Format: <code>ascii</code> oder <code>binary</code> <code>--plate-thickness</code> <code>0.2</code> Dicke der Grundplatte in mm <p>Binaer fuer kleinere Dateien</p> <p>Das binaere STL-Format erzeugt deutlich kleinere Dateien (ca. 50-80% kleiner als ASCII). Empfohlen fuer den regulaeren Einsatz: <pre><code>pixestl -i foto.jpg -p palette.json -o out.zip -w 100 --format binary\n</code></pre></p>"},{"location":"cli-referenz/#kruemmung-curve","title":"Kruemmung (Curve)","text":"<p>Erzeugt zylindrisch gekruemmte Lithophanien statt flacher Platten.</p> Parameter Kurzform Standard Beschreibung <code>--curve</code> <code>-C</code> <code>0</code> Kruemmungswinkel in Grad (0=flach, 90=Viertelzylinder, 360=Vollzylinder) <p>Der Winkel gibt an, welchen Bogenabschnitt eines Zylinders die Lithophanie umspannt:</p> Wert Ergebnis <code>0</code> Flache Lithophanie (Standard, keine Kruemmung) <code>5</code> Minimal gekruemmt, fast flach <code>90</code> Viertelzylinder <code>180</code> Halbzylinder <code>360</code> Vollzylinder (die Enden treffen sich) <p>Wie die Kruemmung wirkt</p> <p>Die X-Achse (Breite) der Lithophanie wird um einen Zylinder gewickelt. Die Y-Achse (Hoehe) bleibt die Zylinderachse. Die Z-Achse (Tiefe/Dicke) wird zum radialen Abstand von der Zylinderoberflaeche. Der Radius wird automatisch so berechnet, dass die Bogenlaenge der eingestellten Breite entspricht.</p> <p>Beispiele</p> <pre><code># Viertelzylinder, 120mm breit\npixestl -i foto.jpg -p palette.json -o out.zip -w 120 -C 90\n\n# Vollzylinder (Lampe/Vase), 200mm Umfang\npixestl -i foto.jpg -p palette.json -o out.zip -w 200 -C 360\n\n# Leichte Kruemmung fuer Bilderrahmen\npixestl -i foto.jpg -p palette.json -o out.zip -w 100 -C 30\n</code></pre>"},{"location":"cli-referenz/#kalibrierung","title":"Kalibrierung","text":"<p>Generiert ein Kalibrierungs-Testmuster direkt aus der Palette, ohne dass ein Eingabebild benoetigt wird.</p> Parameter Beschreibung <code>--calibrate</code> Kalibrierungsmodus: Erzeugt Testmuster statt einer Lithophanie <p>Im Kalibrierungsmodus generiert PIXEstL ein Raster von Testquadraten (10 x 10 mm) fuer jedes aktive Filament in der Palette. Fuer jedes Filament werden Quadrate mit 1 bis N Schichten erzeugt (N = <code>--color-layers</code>).</p> <p>Die Ausgabe ist ein ZIP-Archiv mit:</p> <ul> <li><code>calibration-plate.stl</code> \u2014 Grundplatte</li> <li><code>calibration-[Filament].stl</code> \u2014 Testquadrate pro Filament (eine Reihe mit aufsteigender Schichtanzahl)</li> </ul> <p>Kalibrierungs-Testmuster generieren</p> <pre><code># 5-Schicht-Kalibrierung\npixestl --calibrate -p palette/filament-palette-0.10mm.json -o kalibrierung.zip\n\n# 7-Schicht-Kalibrierung\npixestl --calibrate -p palette.json -o kalibrierung.zip --color-layers 7\n</code></pre> <p>Workflow</p> <ol> <li>Testmuster generieren: <code>pixestl --calibrate -p palette.json -o kalibrierung.zip</code></li> <li>ZIP in Slicer laden und drucken (jede STL dem passenden Filament zuweisen)</li> <li>Gedruckte Testfelder vor Lichtquelle halten und fotografieren</li> <li>HSL-Werte pro Feld messen und in die Palette-JSON eintragen</li> </ol> <p>Siehe Filament-Kalibrierung fuer die vollstaendige Anleitung.</p>"},{"location":"cli-referenz/#erweiterte-optionen","title":"Erweiterte Optionen","text":"<p>Parameter fuer Feinsteuerung und Debugging.</p> Parameter Standard Beschreibung <code>--color-distance</code> <code>cie-lab</code> Farbdistanz-Methode: <code>rgb</code> oder <code>cie-lab</code> <code>--pixel-method</code> <code>additive</code> Pixel-Methode: <code>additive</code> oder <code>full</code> <code>--color-number</code> <code>0</code> Maximale Farbanzahl pro Gruppe (0 = alle) <code>--debug</code> - Debug-Ausgaben aktivieren"},{"location":"cli-referenz/#farbdistanz-methode","title":"Farbdistanz-Methode","text":"Methode Beschreibung <code>cie-lab</code> Wahrnehmungstreue Distanz im CIE-Lab-Farbraum (empfohlen) <code>rgb</code> Euklidische Distanz im RGB-Farbraum (schneller)"},{"location":"cli-referenz/#pixel-methode","title":"Pixel-Methode","text":"Methode Beschreibung <code>additive</code> Verschiedene Farbschichten werden gestapelt (mehr Farben) <code>full</code> Jeder Pixel verwendet nur eine Filamentfarbe (einfacher) <p>Siehe CMYK Farbmischung fuer eine ausfuehrliche Erklaerung beider Methoden.</p>"},{"location":"cli-referenz/#farbanzahl-und-ams-gruppen","title":"Farbanzahl und AMS-Gruppen","text":"<p>Der Parameter <code>--color-number</code> steuert, wie viele Farben pro Druckgruppe verwendet werden:</p> Wert Bedeutung <code>0</code> Alle verfuegbaren Farben verwenden (Standard) <code>4</code> Maximal 4 Farben pro Gruppe (1 AMS) <code>8</code> Maximal 8 Farben pro Gruppe (2 AMS) <code>16</code> Maximal 16 Farben pro Gruppe (4 AMS) <p>Druck mit einem einzelnen AMS (4 Farben)</p> <pre><code>pixestl -i foto.jpg -p palette.json -o out.zip -w 100 --color-number 4\n</code></pre>"},{"location":"cli-referenz/#vollstaendige-beispiele","title":"Vollstaendige Beispiele","text":""},{"location":"cli-referenz/#flache-lithophanie-standard","title":"Flache Lithophanie (Standard)","text":"<pre><code>pixestl \\\n  -i urlaubsfoto.jpg \\\n  -p palette/filament-palette-0.10mm.json \\\n  -o lithophanie.zip \\\n  -w 120 \\\n  --color-layers 5 \\\n  --color-pixel-width 0.8 \\\n  --texture-pixel-width 0.25 \\\n  --format binary \\\n  --color-distance cie-lab \\\n  --pixel-method additive\n</code></pre> <p>Erzeugt eine 120mm breite, flache Farb-Lithophanie mit 5 Farbschichten, CIE-Lab-Farbabgleich und binaerer STL-Ausgabe.</p>"},{"location":"cli-referenz/#gekruemmte-lithophanie-halbzylinder","title":"Gekruemmte Lithophanie (Halbzylinder)","text":"<pre><code>pixestl \\\n  -i panorama.jpg \\\n  -p palette/filament-palette-0.10mm.json \\\n  -o panorama_curved.zip \\\n  -w 200 \\\n  -C 180 \\\n  --format binary\n</code></pre> <p>Erzeugt eine 200mm breite Halbzylinder-Lithophanie. Ideal fuer Panoramafotos, die als freistehendes Leuchtbild aufgestellt werden.</p>"},{"location":"cli-referenz/#kalibrierungs-testmuster","title":"Kalibrierungs-Testmuster","text":"<pre><code>pixestl --calibrate \\\n  -p palette/filament-palette-0.10mm.json \\\n  -o kalibrierung.zip \\\n  --color-layers 7\n</code></pre> <p>Generiert Kalibrierungs-Testfelder fuer alle aktiven Filamente mit 7 Schichtstufen.</p>"},{"location":"faq/","title":"FAQ \u2013 H\u00e4ufige Fragen","text":"<p>Antworten auf die h\u00e4ufigsten Fragen rund um PIXEstL, Kalibrierung, Farben und Druck.</p>"},{"location":"faq/#farben-und-qualitat","title":"Farben und Qualit\u00e4t","text":""},{"location":"faq/#meine-farben-sehen-falsch-aus-was-tun","title":"Meine Farben sehen falsch aus \u2013 was tun?","text":"<p>Das ist der h\u00e4ufigste Fehler und hat meist eine dieser Ursachen:</p> <p>1. Palette nicht oder schlecht kalibriert Die mitgelieferte Beispiel-Palette ist f\u00fcr Bambu Lab PLA Basic kalibriert. F\u00fcr andere Filamente weichen die Farben stark ab. \u2192 Kalibrierung neu durchf\u00fchren</p> <p>2. Falsche Filament-Zuweisung im Slicer Jede STL-Datei muss dem richtigen Filament-Slot zugewiesen sein. Der Dateiname verr\u00e4t die Farbe, z.B. <code>layer-Cyan[...].stl</code> \u2192 Cyan-Slot. \u2192 Slicer-Anleitung</p> <p>3. Inkonsistente Beleuchtung beim Kalibrieren Wenn beim Kalibrieren andere Lichtverh\u00e4ltnisse herrschten als beim sp\u00e4teren Betrachten, stimmen die Farben nicht. \u2192 Immer dieselbe Lichtquelle (idealerweise ein LED-Panel mit ~6000K) verwenden.</p> <p>4. Falsches Infill Infill muss auf 100% gesetzt sein. Bei weniger str\u00f6mt Licht unkontrolliert durch die Hohlr\u00e4ume und verf\u00e4lscht die Farbwiedergabe.</p>"},{"location":"faq/#wie-viele-farben-kann-ich-verwenden","title":"Wie viele Farben kann ich verwenden?","text":"<p>Das h\u00e4ngt von deiner AMS-Konfiguration ab:</p> AMS-Konfiguration Max. gleichzeitige Farben Parameter 1 AMS (4 Slots) 4 Farben <code>--color-number 4</code> 2 AMS (8 Slots) 8 Farben <code>--color-number 8</code> 4 AMS (16 Slots) 16 Farben <code>--color-number 16</code> Theoretisch unbegrenzt Alle Palette-Farben <code>--color-number 0</code> <p>Mit mehr Farben als AMS-Slots kannst du trotzdem drucken \u2013 PIXEstL teilt die Farben in Gruppen auf. Der Drucker pausiert dann zwischen den Gruppen f\u00fcr einen manuellen Filamentwechsel.</p>"},{"location":"faq/#wie-lange-dauert-die-generierung","title":"Wie lange dauert die Generierung?","text":"Szenario Typische Zeit 100 mm breit, Standardeinstellungen 5\u201315 Sekunden 150 mm breit, feine Pixel (0.5 mm) 30\u201360 Sekunden 200 mm breit, sehr fein (0.3 mm) 2\u20135 Minuten Sehr gro\u00dfes Eingabebild (&gt; 4K) 15\u201360 Sekunden <p>PIXEstL nutzt automatisch alle CPU-Kerne \u2013 auf modernen Mehrkern-Prozessoren ist die Generierung deutlich schneller.</p>"},{"location":"faq/#kann-ich-jpg-statt-png-verwenden","title":"Kann ich JPG statt PNG verwenden?","text":"<p>Ja, PIXEstL unterst\u00fctzt JPG, PNG und WebP. JPG funktioniert gut, solange die Qualit\u00e4tsstufe hoch ist.</p> <p>Stark komprimierte JPEGs (erkennbar an sichtbarer Blockbildung) k\u00f6nnen zu sichtbaren Artefakten in der Lithophanie f\u00fchren. Im Zweifel die PNG-Version des Bildes verwenden.</p>"},{"location":"faq/#was-ist-der-unterschied-zwischen-farb-ebene-und-textur-ebene","title":"Was ist der Unterschied zwischen Farb-Ebene und Textur-Ebene?","text":"<p>Eine Farb-Lithophanie besteht aus zwei \u00fcbereinanderliegenden Schichten-Systemen:</p> Ebene Funktion Steuert Farb-Ebene Erzeugt die Farben durch Stapeln transparenter Filamente (CMYK-Prinzip) Welche Farbe ein Pixel hat Textur-Ebene Erzeugt das klassische Lithophanie-Relief (dicker = dunkler) Wie hell/dunkel ein Pixel erscheint <p>Beide Ebenen zusammen ergeben eine vollst\u00e4ndige Farb-Lithophanie. Mit <code>--no-color</code> erh\u00e4ltst du eine klassische Graustufen-Lithophanie (nur Textur), mit <code>--no-texture</code> nur eine flache Farbschicht (selten sinnvoll).</p>"},{"location":"faq/#mein-slicer-erkennt-die-farben-nicht-richtig","title":"Mein Slicer erkennt die Farben nicht richtig","text":"<p>H\u00e4ufige Ursachen:</p> <ul> <li>Dateien nicht als einzelnes Objekt geladen: In Bambu Studio beim Import \"Load as single object?\" \u2192 Yes ausw\u00e4hlen.</li> <li>Falsche Filament-Slot-Zuweisung: Im Objects Panel jeden Eintrag pr\u00fcfen und das richtige Filament zuweisen.</li> <li>Platte, Wei\u00df und Textur auf demselben Slot: <code>layer-plate.stl</code>, <code>layer-White[...].stl</code> und <code>layer-texture-[...].stl</code> m\u00fcssen alle auf Slot 1 (Wei\u00df).</li> </ul> <p>Detaillierte Slicer-Anleitung \u2192</p>"},{"location":"faq/#drucker-und-hardware","title":"Drucker und Hardware","text":""},{"location":"faq/#funktioniert-pixestl-ohne-ams-mit-einem-anderen-drucker","title":"Funktioniert PIXEstL ohne AMS / mit einem anderen Drucker?","text":"<p>Ja! PIXEstL erzeugt Standard-STL-Dateien und ist drucker-unabh\u00e4ngig.</p> <p>Ohne AMS musst du die Filamente manuell wechseln \u2013 zeitaufw\u00e4ndig, aber machbar:</p> <ol> <li>Pausen an den richtigen Schichten im Slicer eintragen</li> <li>Drucker pausieren lassen</li> <li>Filament manuell wechseln und Druck fortsetzen</li> </ol> <p>Andere Slicer: OrcaSlicer, PrusaSlicer und Cura funktionieren ebenfalls. Wichtig: Multi-Material-Druck muss unterst\u00fctzt werden.</p> <p>Ohne AMS \u2013 einfacher Einstieg</p> <p>Verwende <code>--no-color</code>, um nur eine klassische Graustufen-Lithophanie zu erzeugen. Diese ben\u00f6tigt nur wei\u00dfes Filament und keinen Farbwechsel.</p>"},{"location":"faq/#welche-filamente-eignen-sich","title":"Welche Filamente eignen sich?","text":"<p>Transparente oder transluzente Filamente aus PLA oder PETG sind ideal.</p> Eigenschaft Geeignet Weniger geeignet Transparenz Transparent / transluzent Opak / deckend Material PLA, PETG ABS, TPU Oberfl\u00e4che Glatt (Standard PLA) Matt (streut Licht zu stark) <p>Empfehlung: Bambu Lab PLA Basic (Transparent) liefert sehr gute Ergebnisse.</p>"},{"location":"faq/#welche-nozzle-groe-wird-empfohlen","title":"Welche Nozzle-Gr\u00f6\u00dfe wird empfohlen?","text":"<p>Eine 0.2 mm Nozzle liefert die besten Ergebnisse. Eine 0.4 mm Nozzle funktioniert ebenfalls, sollte aber mit gr\u00f6beren Pixel-Einstellungen kombiniert werden (<code>--color-pixel-width 1.0</code>).</p>"},{"location":"faq/#technische-fragen","title":"Technische Fragen","text":""},{"location":"faq/#was-bedeutet-additive-vs-full-pixel-methode","title":"Was bedeutet \"additive\" vs. \"full\" Pixel-Methode?","text":"Methode Prinzip Wann verwenden? <code>additive</code> (Standard) Transparente Farbschichten werden gestapelt. Durch Mischung entstehen viele Farbt\u00f6ne. Fotos und Bilder mit Farbverl\u00e4ufen <code>full</code> Jeder Pixel besteht aus nur einer einzigen Filamentfarbe \u2013 keine Mischung. Einfache Logos mit wenigen satten Farben"},{"location":"faq/#muss-ich-wei-als-filament-haben","title":"Muss ich Wei\u00df als Filament haben?","text":"<p>Im additiven Modus (Standard) ja \u2013 Wei\u00df ist Pflicht. Es f\u00fcllt die Pixel-Schichten auf, die keine andere Farbe ben\u00f6tigen, und sorgt f\u00fcr gleichm\u00e4\u00dfige Dicke.</p> <p>Im <code>full</code>-Modus ist Wei\u00df optional (dann nur als weitere Farboption).</p>"},{"location":"faq/#wie-gro-werden-die-stl-dateien","title":"Wie gro\u00df werden die STL-Dateien?","text":"Einstellung Auswirkung auf Dateigr\u00f6\u00dfe <code>--color-pixel-width</code> kleiner Viel gr\u00f6\u00dfere Dateien <code>--texture-pixel-width</code> kleiner Gr\u00f6\u00dfere Textur-STL <code>--format binary</code> 50\u201380 % kleiner als ASCII Lithophanie-Breite gr\u00f6\u00dfer Proportional mehr Geometrie <p>Typische Gesamtgr\u00f6\u00dfe: 20\u2013100 MB (ASCII), 5\u201320 MB (binary).</p>"},{"location":"faq/#kann-ich-eine-lithophanie-auch-als-zylinder-oder-lampenschirm-drucken","title":"Kann ich eine Lithophanie auch als Zylinder oder Lampenschirm drucken?","text":"<p>Ja! Mit dem Parameter <code>-C</code> (oder <code>--curve</code>) kr\u00fcmmst du die Lithophanie:</p> <pre><code># Halbzylinder (steht frei aufgestellt)\npixestl -i foto.jpg -p palette.json -o out.zip -w 200 -C 180\n\n# Vollzylinder (Lampenschirm)\npixestl -i foto.jpg -p palette.json -o out.zip -w 300 -C 360\n</code></pre>"},{"location":"faq/#warum-andert-sich-die-qualitat-nicht-wenn-ich-ein-groeres-bild-verwende","title":"Warum \u00e4ndert sich die Qualit\u00e4t nicht, wenn ich ein gr\u00f6\u00dferes Bild verwende?","text":"<p>Die physische Aufl\u00f6sung der Lithophanie ist durch <code>--color-pixel-width</code> begrenzt, nicht durch die Bildaufl\u00f6sung. Bei 100 mm Breite und 0.8 mm Pixelbreite gibt es nur 125 Pixel in der Breite \u2013 egal ob das Eingabebild 500 oder 4000 Pixel breit ist.</p> <p>Gr\u00f6\u00dfere Bilder sorgen nur f\u00fcr etwas besseres Antialiasing beim Herunterskalieren \u2013 ein 4000-Pixel-Bild ist hier kaum besser als ein 1000-Pixel-Bild.</p> <p>Empfehlung: Bilder zwischen 500 und 2000 Pixeln Breite f\u00fcr optimale Rechenzeit.</p>"},{"location":"faq/#warum-brauche-ich-color-layer-thickness-kann-ich-das-ignorieren","title":"Warum brauche ich <code>--color-layer-thickness</code>? Kann ich das ignorieren?","text":"<p>Im Normalfall (0.10 mm Schichth\u00f6he im Slicer) kannst du den Standardwert verwenden.</p> <p>Wenn du eine andere Schichth\u00f6he verwendest (z.B. 0.08 mm), musst du: 1. Eine neue Palette f\u00fcr diese Schichth\u00f6he kalibrieren 2. <code>--color-layer-thickness 0.08</code> beim Aufruf setzen</p> <p>Die Kalibrierungswerte gelten exakt nur f\u00fcr die gemessene Schichth\u00f6he.</p>"},{"location":"faq/#nachster-schritt","title":"N\u00e4chster Schritt","text":"<p>Noch Fragen? Schau in die vollst\u00e4ndige Anleitung \u2192 oder \u00f6ffne ein Issue auf GitHub.</p>"},{"location":"galerie/","title":"Galerie","text":"<p>Hier siehst du, was mit PIXEstL m\u00f6glich ist \u2013 alles hinterleuchtete Lithophanien aus transparentem PLA-Filament.</p>"},{"location":"galerie/#kunst-und-klassiker","title":"Kunst und Klassiker","text":""},{"location":"galerie/#charaktere-und-popkultur","title":"Charaktere und Popkultur","text":""},{"location":"galerie/#natur-und-motive","title":"Natur und Motive","text":""},{"location":"galerie/#portraits","title":"Portraits","text":""},{"location":"galerie/#druckvarianten-im-vergleich","title":"Druckvarianten im Vergleich","text":"<p>Die folgenden Bilder zeigen unterschiedliche Druckeinstellungen und Methoden im direkten Vergleich.</p> <p></p> <p></p> <p></p> <p>1 AMS = 4 Farben</p> <p>Bilder mit dem Zusatz \"1 AMS\" wurden mit nur 4 Filamenten (einem einzelnen AMS) gedruckt. Trotz der reduzierten Farbpalette sind die Ergebnisse beeindruckend. Verwende <code>--color-number 4</code>, um die Farbanzahl auf eine AMS-Gruppe zu begrenzen.</p>"},{"location":"galerie/#teile-dein-ergebnis","title":"Teile dein Ergebnis!","text":"<p>Hast du eine Lithophanie mit PIXEstL gedruckt? Wir freuen uns \u00fcber dein Ergebnis!</p> <p>Ergebnis auf GitHub zeigen</p>"},{"location":"galerie/#nachster-schritt","title":"N\u00e4chster Schritt","text":"<p>Inspiriert? Dann starte jetzt mit deiner eigenen Lithophanie:</p> <p>Schnellstart \u2192 Anleitung \u2192</p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#systemvoraussetzungen","title":"Systemvoraussetzungen","text":"Komponente Mindestanforderung Betriebssystem Windows, macOS oder Linux Rust Version 1.75 oder neuer CPU Mehrkernprozessor empfohlen (fuer parallele Verarbeitung) RAM 100 MB fuer typische Bilder, 500 MB+ fuer 4K-Bilder Festplatte ~50 MB fuer das Programm + Platz fuer STL-Ausgaben"},{"location":"installation/#rust-installieren","title":"Rust installieren","text":"<p>Falls Rust noch nicht installiert ist:</p> <pre><code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n</code></pre> <p>Unter Windows: Lade den Rust-Installer herunter.</p>"},{"location":"installation/#pixestl-installieren","title":"PIXEstL installieren","text":""},{"location":"installation/#aus-dem-quellcode-bauen","title":"Aus dem Quellcode bauen","text":"<pre><code># Repository klonen\ngit clone https://github.com/feurer98/PIXEstL.git\ncd PIXEstL/rust\n\n# Release-Build erstellen (optimiert)\ncargo build --release\n</code></pre> <p>Das fertige Programm liegt unter:</p> <pre><code>PIXEstL/rust/target/release/pixestl\n</code></pre> <p>Tipp</p> <p>Der Release-Build nutzt Link-Time-Optimization (LTO) und ist ca. 10x schneller als der Debug-Build. Die Kompilierung dauert dadurch etwas laenger (~1-2 Minuten).</p>"},{"location":"installation/#installation-ueberpruefen","title":"Installation ueberpruefen","text":"<pre><code>./target/release/pixestl --help\n</code></pre> <p>Du solltest die Hilfe-Ausgabe mit allen verfuegbaren Optionen sehen.</p>"},{"location":"installation/#naechste-schritte","title":"Naechste Schritte","text":"<p>Bereit? Dann weiter zum Schnellstart!</p>"},{"location":"schnellstart/","title":"Schnellstart","text":"<p>Dein erstes Ergebnis in unter 10 Minuten \u2013 wenn PIXEstL bereits installiert ist.</p> <p>Voraussetzungen auf einen Blick: PIXEstL installiert, ein Foto (JPG/PNG), Bambu Lab AMS mit transparenten CMYK-Filamenten.</p>"},{"location":"schnellstart/#schritt-1-repository-klonen-und-bauen","title":"Schritt 1: Repository klonen und bauen","text":"<pre><code>git clone https://github.com/feurer98/PIXEstL.git\ncd PIXEstL/rust\ncargo build --release\n</code></pre> <p>Dieser Befehl l\u00e4dt den Quellcode herunter und erstellt das fertige Programm. Die Kompilierung dauert beim ersten Mal 1\u20133 Minuten.</p> <p>Mehr Details zur Installation \u2192</p>"},{"location":"schnellstart/#schritt-2-beispiel-palette-prufen","title":"Schritt 2: Beispiel-Palette pr\u00fcfen","text":"<p>Im Repository liegt bereits eine fertig kalibrierte Palette f\u00fcr Bambu Lab PLA Basic:</p> <pre><code>ls ../palette/\n# filament-palette-0.10mm.json  \u2190 diese verwenden wir\n</code></pre> <p>Eigene Filamente?</p> <p>Die Beispiel-Palette ist auf Bambu Lab PLA Basic (Cyan, Magenta, Yellow, White) kalibriert. F\u00fcr andere Filamente musst du zun\u00e4chst kalibrieren \u2013 das lohnt sich!</p>"},{"location":"schnellstart/#schritt-3-lithophanie-generieren","title":"Schritt 3: Lithophanie generieren","text":"<pre><code>./target/release/pixestl \\\n  -i mein_bild.jpg \\\n  -p ../palette/filament-palette-0.10mm.json \\\n  -o ausgabe.zip \\\n  -w 100\n</code></pre> Parameter Bedeutung <code>-i mein_bild.jpg</code> Dein Eingabebild (JPG, PNG oder WebP) <code>-p \u2026palette.json</code> Die Palette mit deinen Filamentfarben <code>-o ausgabe.zip</code> Die Ausgabedatei \u2013 ein ZIP-Archiv mit allen STL-Dateien <code>-w 100</code> Breite der Lithophanie in Millimetern <p>Nach wenigen Sekunden liegt die Datei <code>ausgabe.zip</code> bereit.</p> <p>Alle Parameter erkl\u00e4rt \u2192</p>"},{"location":"schnellstart/#schritt-4-zip-entpacken","title":"Schritt 4: ZIP entpacken","text":"<pre><code>unzip ausgabe.zip -d ausgabe/\nls ausgabe/\n</code></pre> <p>Du siehst mehrere STL-Dateien \u2013 je eine pro Filamentfarbe:</p> <pre><code>ausgabe/\n\u251c\u2500\u2500 layer-plate.stl                     \u2190 Grundplatte (Wei\u00df)\n\u251c\u2500\u2500 layer-Cyan[PLA Basic].stl           \u2190 Cyan-Farbschicht\n\u251c\u2500\u2500 layer-Magenta[PLA Basic].stl        \u2190 Magenta-Farbschicht\n\u251c\u2500\u2500 layer-Yellow[PLA Basic].stl         \u2190 Gelb-Farbschicht\n\u251c\u2500\u2500 layer-White[PLA Basic].stl          \u2190 Wei\u00df-F\u00fcllschicht\n\u2514\u2500\u2500 layer-texture-White[PLA Basic].stl  \u2190 Helligkeitsschicht\n</code></pre>"},{"location":"schnellstart/#schritt-5-in-bambu-studio-laden-und-drucken","title":"Schritt 5: In Bambu Studio laden und drucken","text":"<ol> <li>\u00d6ffne Bambu Studio</li> <li>Gehe zu File \u2192 Import und w\u00e4hle alle STL-Dateien aus dem <code>ausgabe/</code>-Ordner</li> <li>Best\u00e4tige: \"Load as single object?\" \u2192 Yes</li> <li>Weise jeder Schicht das richtige Filament zu (Dateiname verr\u00e4t die Farbe)</li> <li>Infill auf 100% setzen \u2013 das ist Pflicht!</li> <li>Drucken starten</li> </ol> <p>Detaillierte Slicer-Anleitung \u2192</p>"},{"location":"schnellstart/#ergebnis","title":"Ergebnis","text":"<p>Nach dem Druck die Lithophanie vor eine Lichtquelle halten \u2013 und staunen!</p>"},{"location":"schnellstart/#nachste-schritte","title":"N\u00e4chste Schritte","text":"<ul> <li>Palette kalibrieren \u2013 Eigene Filamente einmessen f\u00fcr perfekte Farben</li> <li>Bild vorbereiten \u2013 Welche Fotos funktionieren besonders gut?</li> <li>Alle Parameter \u2013 Was kann PIXEstL sonst noch?</li> <li>Galerie \u2013 Inspiration aus der Community</li> </ul>"},{"location":"anleitung/best-practices/","title":"Best Practices fuer Farblithophanien","text":"<p>Diese Seite fasst die wichtigsten Tipps und Tricks zusammen, die aus der Community-Erfahrung mit PIXEstL hervorgegangen sind. Sie basiert auf Erkenntnissen aus zahlreichen Anwenderbeitraegen und Tests.</p>"},{"location":"anleitung/best-practices/#bildvorbereitung","title":"Bildvorbereitung","text":"<p>Die Qualitaet des Eingabebildes hat grossen Einfluss auf das Endergebnis. Mit etwas Vorverarbeitung lassen sich deutlich bessere Lithophanien erzeugen.</p>"},{"location":"anleitung/best-practices/#kontrast-und-helligkeit","title":"Kontrast und Helligkeit","text":"<ul> <li>Kontrast leicht erhoehen: Transparente Filamente tendieren dazu, Farben auszuwaschen. Ein leicht erhoehter Kontrast im Quellbild kompensiert diesen Effekt.</li> <li>Highlights zuruecknehmen: Ueberbelichtete Bereiche (reine Weissflaechen) fuehren zu flachen, detaillosen Stellen in der Lithophanie. Reduziere die Highlights im Quellbild um 10-20%.</li> <li>Schatten aufhellen: Zu dunkle Bereiche werden in der Lithophanie undifferenziert schwarz. Helle die Schatten leicht auf, um Details zu erhalten.</li> </ul>"},{"location":"anleitung/best-practices/#bildgroesse-und-aufloesung","title":"Bildgroesse und Aufloesung","text":"<ul> <li>Mindestens so viele Pixel wie Farbpixel: PIXEstL rechnet das Bild auf die Farbpixel-Anzahl herunter. Bei <code>--width 100</code> und <code>--color-pixel-width 0.8</code> entstehen 125 Farbpixel. Ein Bild mit 125 Pixel Breite reicht theoretisch; 250-500 Pixel liefern durch das Lanczos3-Resampling bessere Ergebnisse.</li> <li>Keine kuenstliche Hochskalierung: Ein 200px-Bild auf 2000px hochzuskalieren bringt keine zusaetzlichen Details. Verwende das Originalbild in seiner natuerlichen Aufloesung.</li> <li>Seitenverhaeltnis pruefen: Wenn du <code>--width</code> und <code>--height</code> gleichzeitig angibst, achte darauf, dass das Seitenverhaeltnis zum Bild passt. PIXEstL warnt bei Abweichungen.</li> </ul> <p>Aufloesung pruefen</p> <p>PIXEstL zeigt beim Generieren einen Hinweis an, wenn das Bild deutlich mehr Pixel hat als die konfigurierte Farbaufloesung. In diesem Fall kannst du <code>--color-pixel-width</code> verkleinern, um die Schaerfe zu erhoehen (auf Kosten der Dateigr\u00f6sse und Druckzeit).</p>"},{"location":"anleitung/best-practices/#motivwahl","title":"Motivwahl","text":"<ul> <li>Portr\u00e4ts: Hautt\u00f6ne sind mit nur 4 Farben (CMYK) schwierig. Beige- oder Hautfarben-Filamente verbessern Portr\u00e4ts erheblich. Die Beispiel-Palette enthaelt Beige aus diesem Grund.</li> <li>Landschaften: Funktionieren mit CMYK meist gut, da Gruen- und Blauant\u00f6ne dominieren.</li> <li>Hochkontrast-Motive: Text, Logos und Grafiken mit klaren Farben eignen sich besonders gut.</li> <li>Fotos mit vielen Graut\u00f6nen: Schwierig, da Grau aus CMYK gemischt wird und je nach Kalibrierung farbstichig wirken kann.</li> </ul>"},{"location":"anleitung/best-practices/#optimale-druckparameter","title":"Optimale Druckparameter","text":"<p>Die folgenden Werte sind Community-Konsens aus zahlreichen Tests.</p>"},{"location":"anleitung/best-practices/#schichthoehe-und-farbschichten","title":"Schichthoehe und Farbschichten","text":"Parameter Empfehlung Erlaeuterung Schichthoehe 0.08 - 0.12 mm Kleinere Schichthoehen ergeben feinere Farbabstufungen. 0.10mm ist der Standard-Kompromiss. Farbschichten (<code>--color-layers</code>) 5 - 7 5 Schichten reichen fuer die meisten Anwendungen. 7 Schichten bei 0.07mm ergeben noch feinere Farbuebergaenge, brauchen aber eine eigene Palette-Kalibrierung. Farbpixel-Groesse (<code>--color-pixel-width</code>) 0.4 - 0.8 mm 0.8mm ist schnell und robust. 0.4mm liefert doppelte Aufloesung, verdoppelt aber auch die Druckzeit. <p>Kalibrierung und Schichthoehe</p> <p>Die Palette ist immer fuer eine bestimmte Schichthoehe kalibriert. Wenn du von 0.10mm auf 0.07mm wechselst, brauchst du eine neue Kalibrierung. Verwende die Schichthoehe im Dateinamen der Palette (z.B. <code>palette-0.07mm.json</code>).</p>"},{"location":"anleitung/best-practices/#sieben-schichten-community-empfehlung","title":"Sieben Schichten (Community-Empfehlung)","text":"<p>Mehrere erfahrene Anwender empfehlen 7 Farbschichten bei 0.07mm Schichthoehe:</p> <ul> <li>Vorteile: Feinere Farbabstufungen, besseres Blending zwischen Farben, sattere Farben.</li> <li>Nachteile: Laengere Druckzeit, aufwaendigere Kalibrierung (7 statt 5 Testfelder pro Farbe), 9+ Schichten zeigen kaum noch Verbesserung (diminishing returns).</li> <li>Tipp: Starte mit 5 Schichten bei 0.10mm. Wenn die Ergebnisse zufriedenstellen, experimentiere mit 7 Schichten bei 0.07mm fuer noch bessere Qualitaet.</li> </ul>"},{"location":"anleitung/best-practices/#druckgeschwindigkeit-und-ironing","title":"Druckgeschwindigkeit und Ironing","text":"<ul> <li>Langsame Geschwindigkeit: 30-50 mm/s fuer die Farbschichten verbessert die Farbgenauigkeit. Bei hohen Geschwindigkeiten kann die Extrusion ungleichmaessig werden.</li> <li>Ironing aktivieren: Glaettet die Oberflaeche jeder Schicht und eliminiert Druck-Artefakte. Dies ist besonders wichtig fuer die weisse Basisschicht.</li> <li>Filament-Sequenzierung (BambuStudio): Wenn verfuegbar, aktiviere \"By Object\" statt \"By Layer\". Dies reduziert unnoetige Filamentwechsel und verbessert die Druckqualitaet bei vielen Farben.</li> </ul>"},{"location":"anleitung/best-practices/#kalibrierung-zusammenfassung","title":"Kalibrierung \u2014 Zusammenfassung","text":"<p>Die vollstaendige Kalibrierungsanleitung findest du unter Filament-Kalibrierung. Hier die wichtigsten Punkte:</p>"},{"location":"anleitung/best-practices/#die-drei-haeufigsten-fehler","title":"Die drei haeufigsten Fehler","text":"<ol> <li> <p>Nur einen Layer kalibriert: Die Palette braucht HSL-Werte fuer jeden Layer (1 bis 5 oder 1 bis 7). Ein Eintrag mit nur Layer 5 funktioniert, verschenkt aber Farbgenauigkeit.</p> </li> <li> <p>Warme Beleuchtung verwendet: Gluehbirnen und warme LEDs verschieben alle Farbwerte ins Gelbliche. Verwende ausschliesslich neutralweisse LED-Panels (~5500-6500K).</p> </li> <li> <p>Kamera im Automatik-Modus: Der automatische Weissabgleich der Kamera aendert die Farbwerte je nach Umgebung. Verwende den manuellen Modus:</p> <ul> <li>ISO: 50-125</li> <li>Shutter: ~1/180</li> <li>Weissabgleich: 4000-7000K (fixiert)</li> </ul> </li> </ol>"},{"location":"anleitung/best-practices/#layer-nummern-verstehen","title":"Layer-Nummern verstehen","text":"<p>Die Layer-Nummern in der Palette (<code>\"1\"</code>, <code>\"2\"</code>, ..., <code>\"5\"</code>) sind nicht die physische Position im STL. Sie definieren die Farbdichte \u2014 also wie viele Schichten eines Filaments uebereinander gedruckt werden:</p> <ul> <li>Layer \"1\": Duennste Schicht \u2192 hellste, transparenteste Farbe</li> <li>Layer \"5\": Dickste Schicht \u2192 dunkelste, gesaettigtste Farbe</li> </ul> <p>PIXEstL kombiniert verschiedene Filamente in verschiedenen Dichten, um die Zielfarbe jedes Pixels bestmoeglich zu approximieren. Zum Beispiel koennte ein Pixel aus \"2 Schichten Cyan + 3 Schichten Weiss\" bestehen, um ein helles Blau zu erzeugen.</p> <p>Palette-Info nutzen</p> <p>Verwende <code>pixestl --palette-info -p deine-palette.json</code> um zu pruefen, welche Filamente aktiv sind und ob alle Layer-Definitionen vollstaendig sind. PIXEstL zeigt Warnungen an, wenn Layer-Definitionen fehlen.</p>"},{"location":"anleitung/best-practices/#schnell-check-fuer-kalibrierungsergebnisse","title":"Schnell-Check fuer Kalibrierungsergebnisse","text":"<p>Nach dem Kalibrieren solltest du folgende Werte pruefen:</p> <ul> <li>Weiss: H=0, S=0, L=90-100 (fast reines Weiss). Wenn L unter 85 liegt, ist die Beleuchtung zu schwach.</li> <li>Schwarz: K-Wert hoch (dunkel). Schwarz braucht oft nur Layer 4-5, da wenige Schichten keinen sichtbaren Schwarzanteil erzeugen.</li> <li>Hue-Konsistenz: Der Farbton (H) sollte ueber alle Layer relativ konstant bleiben. Wenn H bei Cyan von 200 auf 160 springt, stimmt etwas mit der Beleuchtung nicht.</li> <li>Lightness-Verlauf: L sollte von Layer 1 (hoch, hell) zu Layer 5 (niedrig, dunkel) monoton sinken.</li> </ul>"},{"location":"anleitung/best-practices/#fehlerbehebung","title":"Fehlerbehebung","text":""},{"location":"anleitung/best-practices/#farben-sehen-falsch-aus","title":"\"Farben sehen falsch aus\"","text":"<ol> <li>Palette pruefen: Verwende <code>pixestl --palette-info -p palette.json --color-layers N</code> und pruefe die Warnungen.</li> <li>Beleuchtung pruefen: Hinterleuchte die Lithophanie mit der gleichen Lichtquelle wie bei der Kalibrierung (oder gleichwertiger Farbtemperatur).</li> <li>Layer-Anzahl pruefen: Wenn die Palette auf 5 Layer kalibriert ist, verwende <code>--color-layers 5</code>, nicht mehr.</li> </ol>"},{"location":"anleitung/best-practices/#bild-ist-unscharfblurry","title":"\"Bild ist unscharf/blurry\"","text":"<ol> <li>Farbpixelgroesse pruefen: Bei <code>--color-pixel-width 0.8</code> und <code>--width 80</code> entstehen nur 100 Farbpixel. Verkleinere die Pixelgroesse: <code>--color-pixel-width 0.4</code>.</li> <li>Quellbild pruefen: Das Originalbild muss scharf sein. Ueberpr\u00fcfe es in voller Aufloesung.</li> <li>PIXEstL-Hinweis beachten: Bei der Generierung zeigt PIXEstL einen Hinweis an, wenn die effektive Aufloesung deutlich unter der Bildaufloesung liegt.</li> </ol>"},{"location":"anleitung/best-practices/#vorschau-korrekt-aber-druck-falsch","title":"\"Vorschau korrekt, aber Druck falsch\"","text":"<ol> <li>Transmission beachten: Die Vorschau zeigt die berechnete Farbe, aber im Druck transmittiert das Licht durch alle Schichten. Bei vielen Schichten (&gt;5) kann die Lichtdurchlaessigkeit abnehmen.</li> <li>Filament-Reihenfolge pruefen: Im Slicer die Filament-Zuordnung kontrollieren. Jede STL-Datei im ZIP ist nach dem zugehoerigen Filament benannt.</li> <li>AMS-Slots pruefen: Bei mehr als 4 Farben muss die AMS-Gruppierung (<code>--color-number 4</code>) korrekt konfiguriert sein.</li> </ol>"},{"location":"anleitung/best-practices/#empfohlener-workflow","title":"Empfohlener Workflow","text":"<p>Fuer optimale Ergebnisse empfehlen wir folgenden Ablauf:</p> <ol> <li>Kalibrierungs-Testmuster generieren: <code>pixestl --calibrate -p palette.json -o kalibrierung.zip</code></li> <li>Testmuster drucken, fotografieren und HSL-Werte messen (einmalig pro Filament-Set und Schichthoehe)</li> <li>Palette pruefen: <code>pixestl --palette-info -p palette.json</code></li> <li>Bild vorbereiten: Kontrast erhoehen, Highlights reduzieren</li> <li>Testgenerierung: Mit niedrigerer Aufloesung starten (<code>--color-pixel-width 0.8</code>)</li> <li>STL im Slicer pruefen: Filamentzuordnung und Schichtreihenfolge kontrollieren</li> <li>Feintuning: Bei Bedarf <code>--color-pixel-width</code> verkleinern oder <code>--color-layers</code> erhoehen</li> <li>Optional: Kruemmung hinzufuegen: <code>-C 90</code> bis <code>-C 360</code> fuer zylindrische Formen</li> <li>Finaler Druck: Mit Ironing, langsamer Geschwindigkeit, korrekter Schichthoehe</li> </ol>"},{"location":"anleitung/best-practices/#naechste-schritte","title":"Naechste Schritte","text":"<ul> <li>Filament-Kalibrierung \u2014 Detaillierte Kalibrierungsanleitung</li> <li>Palette-Format \u2014 JSON-Struktur der Palette</li> <li>Lithophanie generieren \u2014 Generierungsprozess im Detail</li> <li>Slicer-Einstellungen \u2014 STL in BambuStudio importieren</li> </ul>"},{"location":"anleitung/bild-vorbereiten/","title":"Bild vorbereiten","text":"<p>Bevor du PIXEstL startest, lohnt es sich, kurz \u00fcber das Eingabebild nachzudenken. Nicht jedes Foto eignet sich gleich gut \u2013 mit ein paar einfachen Tricks holst du das Maximum heraus.</p>"},{"location":"anleitung/bild-vorbereiten/#welche-bildformate-werden-unterstutzt","title":"Welche Bildformate werden unterst\u00fctzt?","text":"<p>PIXEstL akzeptiert drei g\u00e4ngige Formate:</p> Format Empfehlung PNG Beste Qualit\u00e4t, verlustfrei \u2013 ideal f\u00fcr Grafiken und Logos JPG / JPEG Gut f\u00fcr Fotos \u2013 achte auf geringe Komprimierung (hohe Qualit\u00e4tsstufe) WebP Wird unterst\u00fctzt, seltener verwendet <p>JPG-Komprimierung</p> <p>Stark komprimierte JPEGs (kleine Dateigr\u00f6\u00dfe, schlechte Qualit\u00e4t) haben sichtbare Blockartefakte, die sich in der Lithophanie zeigen. Verwende wenn m\u00f6glich das Original oder eine hochqualitative Version.</p>"},{"location":"anleitung/bild-vorbereiten/#was-macht-ein-gutes-bild-fur-eine-lithophanie","title":"Was macht ein gutes Bild f\u00fcr eine Lithophanie?","text":""},{"location":"anleitung/bild-vorbereiten/#gut-geeignet","title":"Gut geeignet","text":"<ul> <li>Hoher Kontrast: Helle und dunkle Bereiche wechseln deutlich ab \u2013 die Texturschicht kann das Helligkeitsprofil gut abbilden.</li> <li>Kr\u00e4ftige Farben: Satte, nicht ausgeblichene Farben ergeben intensivere Farbschichten.</li> <li>Klare Motive: Portraits, Kunstwerke, Landschaften mit klarem Vordergrund funktionieren sehr gut.</li> <li>Gute Ausleuchtung: Gleichm\u00e4\u00dfig belichtete Fotos ohne starke \u00dcber- oder Unterbelichtung.</li> </ul>"},{"location":"anleitung/bild-vorbereiten/#weniger-geeignet","title":"Weniger geeignet","text":"<ul> <li>Sehr dunkle Bilder: Viel Schwarz l\u00e4sst kaum Licht durch \u2013 das Ergebnis wirkt flach und leblos.</li> <li>Sehr helle / \u00fcberbelichtete Bilder: Die Helligkeitsunterschiede fehlen, der Kontrast ist gering.</li> <li>Stark komprimierte JPEGs: Blockartefakte werden in der Lithophanie sichtbar.</li> <li>Bilder mit wenig Kontrast: Nebelige oder flache Bilder verlieren noch mehr bei der Umwandlung.</li> </ul> <p>Gutes Beispiel</p> <p>Ein Portrait mit nat\u00fcrlicher Beleuchtung, kr\u00e4ftigen Farben und scharfem Fokus auf das Gesicht \u2013 wie die Beispiele in der Galerie.</p>"},{"location":"anleitung/bild-vorbereiten/#optimale-bildgroe","title":"Optimale Bildgr\u00f6\u00dfe","text":"<p>Die Aufl\u00f6sung des Eingabebildes beeinflusst nur die Rechenzeit, nicht direkt die Druckqualit\u00e4t \u2013 denn PIXEstL skaliert das Bild auf die physische Gr\u00f6\u00dfe der Lithophanie herunter.</p> <p>Faustformel: Ein 100 mm breites Druck mit 0.8 mm Pixelbreite hat nur 125 Pixel in der Breite.</p> Lithophanie-Breite Pixels in der Breite (bei 0.8 mm) 80 mm 100 Pixel 100 mm 125 Pixel 150 mm 188 Pixel 200 mm 250 Pixel <p>Das bedeutet: Ein 4000-Pixel-breites Bild wird auf 125 Pixel herunterskaliert \u2013 die extra Aufl\u00f6sung hilft beim Antialiasing, aber ein 500-Pixel-Bild reicht in der Regel vollkommen aus.</p> <p>Empfehlung: Bildbreite zwischen 500 und 2000 Pixeln auf der l\u00e4ngeren Seite.</p>"},{"location":"anleitung/bild-vorbereiten/#bild-optimieren-schnelle-anleitung","title":"Bild optimieren \u2013 schnelle Anleitung","text":"<p>Du brauchst daf\u00fcr kein professionelles Bildbearbeitungsprogramm. Windows Paint, GIMP, Photoshop oder Lightroom funktionieren alle.</p>"},{"location":"anleitung/bild-vorbereiten/#kontrast-verbessern","title":"Kontrast verbessern","text":"<p>Wenn dein Bild etwas flach wirkt, erh\u00f6he Kontrast und S\u00e4ttigung leicht:</p> <ul> <li>GIMP: Farben \u2192 Helligkeit-Kontrast, und Farben \u2192 Farbton-S\u00e4ttigung</li> <li>Lightroom: Kontrast (+10 bis +30), Klarheit (+10 bis +20), S\u00e4ttigung (+10 bis +20)</li> <li>Photoshop: Bild \u2192 Korrekturen \u2192 Helligkeit/Kontrast und Farbton/S\u00e4ttigung</li> </ul>"},{"location":"anleitung/bild-vorbereiten/#ausschnitt-wahlen","title":"Ausschnitt w\u00e4hlen","text":"<p>Schneide st\u00f6rende Randbereiche weg. Das Motiv sollte den Bildausschnitt m\u00f6glichst gut ausf\u00fcllen \u2013 Randbereiche ohne Inhalt \"verschwenden\" Druckfl\u00e4che.</p>"},{"location":"anleitung/bild-vorbereiten/#auf-sinnvolle-groe-skalieren","title":"Auf sinnvolle Gr\u00f6\u00dfe skalieren","text":"<p>Skaliere das Bild auf maximal 2000 Pixel Breite \u2013 das spart Rechenzeit und \u00e4ndert die Ausgabequalit\u00e4t praktisch nicht.</p> <ul> <li>GIMP: Bild \u2192 Bild skalieren</li> <li>Windows: Rechtsklick \u2192 Gr\u00f6\u00dfe \u00e4ndern (in der Bildschau)</li> </ul>"},{"location":"anleitung/bild-vorbereiten/#bildausrichtung-und-seitenverhaltnis","title":"Bildausrichtung und Seitenverh\u00e4ltnis","text":"<p>PIXEstL beh\u00e4lt das Seitenverh\u00e4ltnis deines Bildes automatisch bei, wenn du nur <code>-w</code> (Breite) oder <code>-H</code> (H\u00f6he) angibst.</p> <p>Ein Hochformat-Foto (z.B. 3:4) ergibt eine Hochformat-Lithophanie, ein Querformat-Foto eine Querformat-Lithophanie.</p> <p>Wenn du beide Dimensionen angibst, wird das Bild gestreckt oder gestaucht \u2013 das ist in den meisten F\u00e4llen unerw\u00fcnscht.</p>"},{"location":"anleitung/bild-vorbereiten/#nachster-schritt","title":"N\u00e4chster Schritt","text":"<p>Wenn dein Bild bereit ist: PIXEstL ausf\u00fchren \u2192</p>"},{"location":"anleitung/druck/","title":"Drucken &amp; Nachbearbeitung","text":"<p>Diese Seite beschreibt den vollstaendigen Ablauf vom Druckstart bis zur fertigen, hinterleuchteten Farb-Lithophanie.</p>"},{"location":"anleitung/druck/#vor-dem-druck","title":"Vor dem Druck","text":"<p>Gehe diese Checkliste durch, bevor du den Druck startest:</p> <ul> <li>[x] Alle Filamente geladen (AMS oder manuell eingesetzt)</li> <li>[x] Duese gereinigt (0.2mm Duese empfohlen fuer beste Detailwiedergabe)</li> <li>[x] Druckbett sauber und korrekt gelevelt</li> <li>[x] Richtiger Plattentyp ausgewaehlt (Cool Plate oder PLA Plate)</li> <li>[x] Slicer-Einstellungen verifiziert -- insbesondere 100% Infill</li> <li>[x] Filament-Zuordnung nochmals geprueft (Farben korrekt zugewiesen)</li> </ul> <p>Vorab-Check nicht ueberspringen</p> <p>Eine falsche Filament-Zuordnung oder fehlender 100%-Infill faellt erst nach Stunden Druckzeit auf. Ein schneller Check spart dir Zeit und Material.</p>"},{"location":"anleitung/druck/#druckvorgang","title":"Druckvorgang","text":"<p>Der Druck einer Farb-Lithophanie laeuft in mehreren Phasen ab:</p>"},{"location":"anleitung/druck/#druckphasen-im-ueberblick","title":"Druckphasen im Ueberblick","text":"Phase Schichten Beschreibung Grundplatte Layer 1--2 Die Stuetzplatte wird mit dem Basis-Filament (Weiss) gedruckt Basis-Fuellschicht Layer 3--6 Weisse Fuellschichten bilden die lichtdurchlaessige Grundlage Farbschichten Layer 7+ Das AMS wechselt zwischen den Filamenten (Cyan, Magenta, Gelb, Weiss) Texturschicht Letzte Schichten Die Relief-/Helligkeitsschicht gibt der Lithophanie ihre Tiefe"},{"location":"anleitung/druck/#typische-druckzeit","title":"Typische Druckzeit","text":"<p>Die Druckdauer haengt von der Groesse und Komplexitaet ab:</p> Breite Ungefaehre Druckzeit 80 mm 3--4 Stunden 120 mm 4--6 Stunden 160 mm 6--8 Stunden <p>Die ersten 10 Schichten beobachten</p> <p>Bleibe waehrend der ersten 10 Schichten in der Naehe des Druckers. Wenn die Grundplatte sich vom Bett loest oder die erste Farbschicht nicht sauber haftet, kannst du frueh eingreifen und den Druck neu starten, anstatt Stunden zu verschwenden.</p>"},{"location":"anleitung/druck/#filamentwechsel-bei-mehr-als-4-farben","title":"Filamentwechsel bei mehr als 4 Farben","text":"<p>Wenn du mehr Farben verwendest, als dein AMS Slots hat (z.B. 6 Farben mit einem 4er-AMS), sind manuelle Filamentwechsel noetig.</p>"},{"location":"anleitung/druck/#ablauf","title":"Ablauf","text":"<ol> <li>Der Drucker pausiert automatisch an den konfigurierten Schichten (siehe Slicer-Einrichtung, Schritt 5)</li> <li>Oeffne das AMS und tausche die Filamentspulen gegen die naechste Farbgruppe</li> <li>Stelle sicher, dass die neuen Filamente korrekt in die Slots eingefuehrt sind</li> <li>Setze den Druck fort ueber das Drucker-Display oder die Bambu Handy App</li> <li>Wiederhole den Vorgang fuer jede weitere Farbgruppe</li> </ol> <p>Filament-Gruppen planen</p> <p>PIXEstL gibt in der Konsole aus, welche Farben in welcher Gruppe zusammengefasst sind. Notiere dir die Gruppen und lege die Spulen bereit, damit der Wechsel schnell geht.</p>"},{"location":"anleitung/druck/#nach-dem-druck","title":"Nach dem Druck","text":""},{"location":"anleitung/druck/#abkuehlen-und-entfernen","title":"Abkuehlen und Entfernen","text":"<ol> <li>Mindestens 30 Minuten abkuehlen lassen -- die Lithophanie auf dem Druckbett vollstaendig auskuehlen lassen</li> <li>Vorsichtig mit einem Spachtel abloesen -- setze den Spachtel flach an einer Ecke an und heble langsam</li> <li>Nicht biegen oder verdrehen -- Lithophanien sind duenn und koennen leicht brechen</li> </ol>"},{"location":"anleitung/druck/#kanten-saeubern","title":"Kanten saeubern","text":"<ul> <li>Leichte Unebenheiten an den Raendern mit feinem Schleifpapier (Koernung 200--400) vorsichtig glaetten</li> <li>Kein grobes Schleifen -- die Farbschichten sind nur wenige Zehntel Millimeter dick</li> </ul> <p>Vorsicht beim Entfernen!</p> <p>Farb-Lithophanien sind duenner und fragiler als herkoemmliche 3D-Drucke. Wende niemals uebermassige Kraft an. Wenn sich der Druck nicht leicht loesen laesst, lege die Druckplatte fuer einige Minuten in den Kuehlschrank -- das thermische Schrumpfen hilft beim Abloesen.</p>"},{"location":"anleitung/druck/#hintergrundbeleuchtung","title":"Hintergrundbeleuchtung","text":"<p>Eine Farb-Lithophanie entfaltet ihre volle Wirkung erst mit der richtigen Beleuchtung von hinten.</p>"},{"location":"anleitung/druck/#empfohlene-lichtquellen","title":"Empfohlene Lichtquellen","text":"Methode Qualitaet Beschreibung LED-Lichtpanel Beste Gleichmaessige Ausleuchtung, idealerweise mit 5000--6500K (Tageslicht) Helles Fenster Gut Die Lithophanie gegen ein sonnenbeschienenes Fenster halten LED-Streifen im Rahmen Gut Selbstbau-Loesung: LED-Strip in einem einfachen Holz- oder 3D-Druckrahmen Smartphone-Bildschirm Ausreichend Weisses Bild auf voller Helligkeit hinter die Lithophanie halten"},{"location":"anleitung/druck/#tipps-fuer-optimale-darstellung","title":"Tipps fuer optimale Darstellung","text":"<ul> <li>Dunkler Raum mit direkter Hintergrundbeleuchtung zeigt die Farben am intensivsten</li> <li>Tageslicht-LEDs (5000--6500K) geben die Farben am neutralsten wieder</li> <li>Warmweisse LEDs (2700--3000K) erzeugen einen leichten Gelbstich, der aber bei manchen Motiven reizvoll wirken kann</li> <li>Der Abstand zwischen Lichtquelle und Lithophanie beeinflusst die Gleichmaessigkeit -- 2--5 cm sind ideal</li> </ul> <p>Beste Farbwiedergabe</p> <p>Die Lithophanie zeigt ihre Farben am besten in einem dunklen Raum mit direkter Hintergrundbeleuchtung im Tageslicht-Bereich (5000--6500K). So kommen die CMYK-Farben am praezisesten zur Geltung.</p>"},{"location":"anleitung/druck/#fehlerbehebung","title":"Fehlerbehebung","text":"<p>Hier findest du Loesungen fuer die haeufigsten Probleme:</p> Problem Moegliche Ursache Loesung Farben stimmen nicht ueberein Palette nicht kalibriert Palette mit eigenen Filamenten neu kalibrieren Bild ist zu dunkel Textur-Parameter nicht optimal <code>texture-min</code> und <code>texture-max</code> in der CLI anpassen Schichten loesen sich voneinander Drucktemperatur zu niedrig Drucktemperatur um 5--10 Grad erhoehen Lithophanie bricht leicht Zu duenne Waende oder Platte Mehr Wall Loops verwenden oder dickere Grundplatte einstellen Stringing zwischen Farben Retraction nicht korrekt eingestellt Retraction-Einstellungen im Slicer pruefen und erhoehen Farben wirken verwaschen Pixel zu grob aufgeloest Feinere <code>color-pixel-width</code> verwenden (kleinerer Wert = mehr Detail) Lithophanie ist komplett weiss Falscher Filament-Slot Filament-Zuordnung im Slicer ueberpruefen Ungleichmaessige Beleuchtung Lichtquelle nicht zentriert LED-Panel mittig hinter der Lithophanie positionieren <p>Weitere Hilfe</p> <p>Wenn dein Problem hier nicht aufgelistet ist, pruefe die FAQ oder oeffne ein Issue auf GitHub.</p>"},{"location":"anleitung/druck/#naechste-schritte","title":"Naechste Schritte","text":"<ul> <li>Slicer-Einrichtung \u2192 \u2013 Zur\u00fcck zur Slicer-Konfiguration</li> <li>Alle Parameter \u2192 \u2013 Vollst\u00e4ndige CLI-Referenz</li> <li>Galerie \u2192 \u2013 Beispiele zur Inspiration</li> </ul>"},{"location":"anleitung/generierung/","title":"Lithophanie generieren","text":"<p>Diese Seite erklaert, wie du mit PIXEstL eine Farb-Lithophanie aus einem Bild erzeugst. Du erfaehrst, welche Parameter zur Verfuegung stehen, wie du sie kombinierst und was die Ausgabe enthaelt.</p>"},{"location":"anleitung/generierung/#grundbefehl","title":"Grundbefehl","text":"<p>Der minimale Befehl fuer eine Lithophanie-Generierung lautet:</p> <pre><code>pixestl -i bild.jpg -p palette.json -o ausgabe.zip -w 100\n</code></pre> Parameter Bedeutung <code>-i bild.jpg</code> Eingabebild (JPG, PNG oder WebP) <code>-p palette.json</code> Palette-Datei mit den kalibrierten Filamentfarben <code>-o ausgabe.zip</code> Ausgabe-Datei (ZIP-Archiv mit STL-Dateien) <code>-w 100</code> Breite der Lithophanie in Millimetern <p>Damit generiert PIXEstL eine 100 mm breite Farb-Lithophanie mit den Standardeinstellungen.</p>"},{"location":"anleitung/generierung/#bildauswahl","title":"Bildauswahl","text":"<p>Die Qualitaet des Eingabebildes beeinflusst das Ergebnis erheblich. Beachte folgende Hinweise:</p> <p>Geeignete Bilder</p> <ul> <li>Hoher Kontrast: Bilder mit deutlichen Hell-Dunkel-Unterschieden erzeugen die eindrucksvollsten Lithophanien.</li> <li>Gute Aufloesung: 500 bis 2000 Pixel Breite sind ideal. Kleinere Bilder verlieren Details, groessere erhoehen die Rechenzeit ohne sichtbaren Gewinn.</li> <li>Portraits und Landschaften funktionieren besonders gut, da sie natuerliche Helligkeitsverlaeufe enthalten.</li> <li>Farbsaettigung: Kraeftige Farben im Eingabebild ergeben kraeftigere Farben in der Lithophanie.</li> </ul> <p>Ungeeignete Bilder</p> <ul> <li>Sehr dunkle Bilder: Wenig Licht scheint durch -- das Ergebnis wirkt flach.</li> <li>Geringe Aufloesung (unter 300px): Zu wenig Detail fuer eine scharfe Lithophanie.</li> <li>Stark komprimierte JPEGs: Kompressionsartefakte werden in der Lithophanie sichtbar.</li> <li>Bilder mit wenig Kontrast: Die Texturschicht kann kaum Helligkeitsunterschiede darstellen.</li> </ul>"},{"location":"anleitung/generierung/#wichtige-parameter","title":"Wichtige Parameter","text":""},{"location":"anleitung/generierung/#groesse","title":"Groesse","text":"Parameter Standard Beschreibung <code>-w</code> / <code>--width</code> 0 Breite der Lithophanie in mm <code>-h</code> / <code>--height</code> 0 Hoehe der Lithophanie in mm <p>Wenn nur <code>-w</code> oder nur <code>-h</code> angegeben wird, berechnet PIXEstL die andere Dimension automatisch, um das Seitenverhaeltnis des Eingabebildes beizubehalten. Typische Breiten liegen zwischen 80 und 150 mm.</p> <pre><code># Breite 120mm, Hoehe wird automatisch berechnet\npixestl -i bild.jpg -p palette.json -o ausgabe.zip -w 120\n\n# Hoehe 80mm, Breite wird automatisch berechnet\npixestl -i bild.jpg -p palette.json -o ausgabe.zip -H 80\n</code></pre>"},{"location":"anleitung/generierung/#farbpixel","title":"Farbpixel","text":"Parameter Standard Beschreibung <code>--color-pixel-width</code> 0.8 mm Breite eines einzelnen Farbpixels. Kleinere Werte ergeben feinere Details, aber groessere STL-Dateien und laengere Druckzeiten. <code>--color-layers</code> 5 Anzahl der Farbschichten (1-5). Mehr Schichten ermoeglichen mehr Farbtiefe, erhoehen aber die Druckzeit. <code>--color-layer-thickness</code> 0.1 mm Dicke pro Farbschicht. Muss mit der Kalibrierung uebereinstimmen. <p>Schichtdicke und Kalibrierung</p> <p>Der Wert von <code>--color-layer-thickness</code> muss exakt der Schichthoehe entsprechen, fuer die deine Palette kalibriert wurde. Die mitgelieferte Palette ist fuer 0.10mm kalibriert. Wenn du 0.08mm im Slicer verwendest, muss eine dafuer kalibrierte Palette erstellt werden.</p>"},{"location":"anleitung/generierung/#textur","title":"Textur","text":"Parameter Standard Beschreibung <code>--texture-pixel-width</code> 0.25 mm Aufloesung der Texturschicht. Feiner als die Farbpixel, um Helligkeitsverlaeufe detailliert abzubilden. <code>--texture-min</code> 0.3 mm Minimale Texturdicke (hellste Stelle) <code>--texture-max</code> 1.8 mm Maximale Texturdicke (dunkelste Stelle) <p>Die Texturschicht codiert die Helligkeit des Bildes als Schichtdicke. Duenne Bereiche lassen mehr Licht durch (hell), dicke Bereiche weniger (dunkel). Der Bereich zwischen <code>--texture-min</code> und <code>--texture-max</code> bestimmt den Kontrastumfang.</p>"},{"location":"anleitung/generierung/#ausgabeformat","title":"Ausgabeformat","text":"Parameter Standard Beschreibung <code>--format</code> ascii <code>ascii</code> oder <code>binary</code>. Binary erzeugt deutlich kleinere Dateien und ist schneller beim Export. <pre><code># Binary-Format fuer kleinere Dateien\npixestl -i bild.jpg -p palette.json -o ausgabe.zip -w 100 --format binary\n</code></pre>"},{"location":"anleitung/generierung/#farbalgorithmus","title":"Farbalgorithmus","text":"Parameter Standard Beschreibung <code>--color-distance</code> cie-lab Methode zur Farbabstandsberechnung. <code>cie-lab</code> ist perzeptuell genauer, <code>rgb</code> ist schneller. <code>--pixel-method</code> additive <code>additive</code> = Farben werden durch uebereinanderliegende transparente Schichten gemischt. <code>full</code> = Jedes Pixel wird aus einem einzigen, vollfarbigen Block gedruckt. <p>CIE-Lab vs. RGB</p> <p>CIE-Lab beruecksichtigt die menschliche Farbwahrnehmung und liefert in der Regel natuerlichere Ergebnisse. RGB ist mathematisch einfacher und kann in seltenen Faellen bei bestimmten Farbpaletten besser funktionieren. Im Zweifelsfall den Standard <code>cie-lab</code> verwenden.</p>"},{"location":"anleitung/generierung/#ams-modus","title":"AMS-Modus","text":"Parameter Standard Beschreibung <code>--color-number</code> 0 Farbgruppierung fuer AMS. <code>0</code> = alle Farben in einer Gruppe. <code>4</code> = Farben werden in Gruppen zu je 4 aufgeteilt (passend fuer einen Bambu Lab AMS mit 4 Slots). <p>Wenn du mehr Farben in der Palette hast, als dein AMS gleichzeitig aufnehmen kann, teilt <code>--color-number 4</code> die Farbschichten in mehrere Gruppen auf. Jede Gruppe kann als separater Druckauftrag nacheinander gedruckt werden.</p>"},{"location":"anleitung/generierung/#kruemmung-curve","title":"Kruemmung (Curve)","text":"Parameter Standard Beschreibung <code>-C</code> / <code>--curve</code> 0 Kruemmungswinkel in Grad. 0 = flach (Standard), 90 = Viertelzylinder, 180 = Halbzylinder, 360 = Vollzylinder. <p>Die Kruemmung wickelt die Lithophanie um einen Zylinder. Der Radius wird automatisch aus der Breite und dem Winkel berechnet, sodass die Bogenlaenge der eingestellten Breite entspricht.</p> <pre><code># Halbzylinder, 150mm breit\npixestl -i panorama.jpg -p palette.json -o panorama.zip -w 150 -C 180\n\n# Vollzylinder (Lampe), 250mm Umfang\npixestl -i bild.jpg -p palette.json -o lampe.zip -w 250 -C 360\n</code></pre> <p>Wann Kruemmung verwenden?</p> <p>Gekruemmte Lithophanien eignen sich besonders fuer:</p> <ul> <li>Panoramafotos als freistehendes Halbzylinder-Bild</li> <li>Lampenschirme als Vollzylinder (360 Grad)</li> <li>Bilderrahmen-Effekt mit leichter Kruemmung (20-45 Grad)</li> </ul>"},{"location":"anleitung/generierung/#weitere-parameter","title":"Weitere Parameter","text":"Parameter Standard Beschreibung <code>--plate-thickness</code> 0.2 mm Dicke der Grundplatte <code>--no-color</code> (Flag) Erzeugt keine Farbschichten (nur Textur, Graustufenlithophanie) <code>--no-texture</code> (Flag) Erzeugt keine Texturschicht (nur Farbe, flach) <code>--calibrate</code> (Flag) Kalibrierungsmodus: Generiert Testmuster statt Lithophanie (kein Bild noetig) <code>--debug</code> (Flag) Gibt zusaetzliche Debug-Informationen aus"},{"location":"anleitung/generierung/#praxis-beispiele","title":"Praxis-Beispiele","text":""},{"location":"anleitung/generierung/#1-standard-portrait-100-mm-breit","title":"1. Standard-Portrait (100 mm breit)","text":"<pre><code>pixestl \\\n  -i portrait.jpg \\\n  -p palette/filament-palette-0.10mm.json \\\n  -o portrait.zip \\\n  -w 100\n</code></pre> <p>Erzeugt eine 100 mm breite Lithophanie mit allen Standardeinstellungen. Gut fuer einen ersten Test.</p>"},{"location":"anleitung/generierung/#2-hochaufloesend-mit-feinen-pixeln","title":"2. Hochaufloesend mit feinen Pixeln","text":"<pre><code>pixestl \\\n  -i landschaft.png \\\n  -p palette/filament-palette-0.10mm.json \\\n  -o landschaft_fein.zip \\\n  -w 150 \\\n  --color-pixel-width 0.5 \\\n  --texture-pixel-width 0.2\n</code></pre> <p>Feinere Farbpixel (0.5 mm statt 0.8 mm) und feinere Textur (0.2 mm statt 0.25 mm) fuer mehr Detail. Die Dateigroesse und Rechenzeit steigen deutlich.</p>"},{"location":"anleitung/generierung/#3-binary-format-fuer-kleinere-dateien","title":"3. Binary-Format fuer kleinere Dateien","text":"<pre><code>pixestl \\\n  -i foto.jpg \\\n  -p palette/filament-palette-0.10mm.json \\\n  -o foto_binary.zip \\\n  -w 100 \\\n  --format binary\n</code></pre> <p>Binary-STL-Dateien sind typischerweise 5-10x kleiner als ASCII-STL-Dateien. Empfohlen fuer groessere Lithophanien.</p>"},{"location":"anleitung/generierung/#4-ams-modus-mit-4-farben","title":"4. AMS-Modus mit 4 Farben","text":"<pre><code>pixestl \\\n  -i bild.jpg \\\n  -p palette/filament-palette-0.10mm.json \\\n  -o bild_ams.zip \\\n  -w 100 \\\n  --color-number 4\n</code></pre> <p>Teilt die Farbschichten in Gruppen zu je 4 Farben auf. Jede Gruppe passt in einen Bambu Lab AMS-Slot-Satz und kann nacheinander gedruckt werden.</p>"},{"location":"anleitung/generierung/#5-nur-textur-graustufen-ohne-farbe","title":"5. Nur Textur (Graustufen, ohne Farbe)","text":"<pre><code>pixestl \\\n  -i bild.jpg \\\n  -p palette/filament-palette-0.10mm.json \\\n  -o bild_grau.zip \\\n  -w 100 \\\n  --no-color\n</code></pre> <p>Erzeugt eine klassische Graustufen-Lithophanie ohne Farbschichten. Die Helligkeit wird ausschliesslich ueber die Texturdicke gesteuert. Benoetigt nur weisses Filament.</p>"},{"location":"anleitung/generierung/#6-gekruemmte-lithophanie-halbzylinder","title":"6. Gekruemmte Lithophanie (Halbzylinder)","text":"<pre><code>pixestl \\\n  -i panorama.jpg \\\n  -p palette/filament-palette-0.10mm.json \\\n  -o panorama_curved.zip \\\n  -w 200 \\\n  -C 180 \\\n  --format binary\n</code></pre> <p>Erzeugt eine 200mm breite Halbzylinder-Lithophanie. Die Kruemmung von 180 Grad wickelt das Bild um einen Halbkreis. Besonders geeignet fuer Panoramafotos, die als freistehendes Leuchtbild aufgestellt werden.</p>"},{"location":"anleitung/generierung/#7-kalibrierungs-testmuster","title":"7. Kalibrierungs-Testmuster","text":"<pre><code>pixestl --calibrate \\\n  -p palette/filament-palette-0.10mm.json \\\n  -o kalibrierung.zip \\\n  --color-layers 7\n</code></pre> <p>Generiert Kalibrierungs-Testfelder (10 x 10 mm) fuer alle aktiven Filamente der Palette. Jedes Filament erhaelt eine Reihe mit Quadraten bei aufsteigender Schichtanzahl (1 bis 7). Die Ausgabe enthaelt separate STL-Dateien pro Filament, sodass jedem das richtige Filament im Slicer zugewiesen werden kann.</p>"},{"location":"anleitung/generierung/#ausgabe-verstehen","title":"Ausgabe verstehen","text":"<p>PIXEstL erzeugt ein ZIP-Archiv mit mehreren STL-Dateien. Jede Datei entspricht einer separaten Druckschicht:</p> <pre><code>ausgabe.zip\n+-- layer-plate.stl                    # Grundplatte\n+-- layer-Cyan[PLA Basic].stl          # Cyan-Farbschicht\n+-- layer-Magenta[PLA Basic].stl       # Magenta-Farbschicht\n+-- layer-Yellow[PLA Basic].stl        # Gelb-Farbschicht\n+-- layer-White[PLA Basic].stl         # Weiss-Fuellschicht\n+-- layer-texture-White[PLA Basic].stl # Textur-/Helligkeitsschicht\n</code></pre> Datei Funktion <code>layer-plate.stl</code> Die Grundplatte, auf der alle anderen Schichten aufbauen. Wird in der Farbe des Texturfilaments (typischerweise Weiss) gedruckt. <code>layer-[Farbe].stl</code> Eine Farbschicht. Enthaelt die Pixel, die diese Filamentfarbe verwenden. Pro aktiver Farbe in der Palette wird eine STL-Datei erzeugt. <code>layer-texture-[Farbe].stl</code> Die Texturschicht, die die Helligkeitsinformation traegt. Wird in Weiss (oder einer anderen hellen Farbe) gedruckt. <p></p> <p>Alle Dateien importieren</p> <p>Im Slicer muessen alle STL-Dateien gleichzeitig als ein Objekt importiert werden. Jede Datei wird dann einem eigenen Filament-Slot zugewiesen. Details zur Slicer-Einrichtung findest du unter Slicer-Einrichtung.</p>"},{"location":"anleitung/generierung/#leistungshinweise","title":"Leistungshinweise","text":"<p>Die Generierungszeit und der Speicherbedarf haengen von mehreren Faktoren ab:</p> Faktor Auswirkung Bildgroesse Groessere Bilder erhoehen Rechenzeit und Speicherbedarf proportional. Farbpixelgroesse Kleinere Pixel (<code>--color-pixel-width</code>) erzeugen viel mehr Geometrie. Eine Halbierung der Pixelgroesse vervierfacht die Dreiecksanzahl. Texturaufloesung Kleinere Texturpixel (<code>--texture-pixel-width</code>) haben den gleichen Effekt wie kleinere Farbpixel. Ausgabebreite Groessere Lithophanien enthalten mehr Pixel und damit mehr Geometrie. Anzahl Farben Mehr aktive Farben erzeugen mehr separate STL-Dateien, aber die Gesamtgeometrie bleibt aehnlich. <p>Typische Richtwerte:</p> Szenario Rechenzeit RAM-Bedarf 100 mm breit, Standardeinstellungen 5-15 Sekunden ~100 MB 150 mm breit, feine Pixel (0.5 mm) 30-60 Sekunden ~200 MB 200 mm breit, sehr fein (0.3 mm) 2-5 Minuten ~500 MB 4K-Eingabebild, Standardeinstellungen 15-30 Sekunden ~500 MB <p>Leistungsoptimierung</p> <ul> <li>Verwende <code>--format binary</code> fuer schnelleren Export und kleinere Dateien.</li> <li>Reduziere die Bildaufloesung auf maximal 2000 Pixel Breite, bevor du es an PIXEstL uebergibst.</li> <li>PIXEstL nutzt automatisch alle verfuegbaren CPU-Kerne fuer die parallele Verarbeitung.</li> </ul>"},{"location":"anleitung/generierung/#naechste-schritte","title":"Naechste Schritte","text":"<ul> <li>Slicer-Einrichtung \u2192 \u2013 STL-Dateien in Bambu Studio laden und konfigurieren</li> <li>Drucken &amp; Nachbearbeitung \u2192 \u2013 Druckeinstellungen und Tipps f\u00fcr das fertige Ergebnis</li> <li>Alle Parameter \u2192 \u2013 Vollst\u00e4ndige Referenz aller CLI-Parameter</li> </ul>"},{"location":"anleitung/kalibrierung/","title":"Filament-Kalibrierung","text":"<p>Die Kalibrierung ist der wichtigste Schritt fuer eine farbgetreue Lithophanie. Ohne Kalibrierung kann PIXEstL nicht wissen, wie dein Filament tatsaechlich aussieht, wenn Licht hindurchscheint.</p>"},{"location":"anleitung/kalibrierung/#warum-kalibrieren","title":"Warum kalibrieren?","text":"<p>Jedes Filament verhaelt sich anders, wenn Licht hindurchscheint. Selbst Filamente gleicher Farbe unterscheiden sich je nach Hersteller, Material und Charge in ihrer Transparenz und Farbwiedergabe. Ein Cyan von Bambu Lab sieht hinterleuchtet voellig anders aus als ein Cyan von OVERTURE oder eSUN.</p> <p>Ohne Kalibrierung keine guten Farben</p> <p>Die mitgelieferte Beispiel-Palette (<code>palette/filament-palette-0.10mm.json</code>) ist auf bestimmte Bambu Lab PLA-Filamente kalibriert. Wenn du andere Filamente verwendest, muessen die HSL-Werte neu gemessen werden. Andernfalls weichen die Farben deiner Lithophanie stark vom Originalbild ab.</p> <p>Die Kalibrierung erfasst die HSL-Werte (Farbton, Saettigung, Helligkeit) deiner Filamente bei verschiedenen Schichtdicken (1 bis 5 Schichten). PIXEstL nutzt diese Werte, um die optimale Farbmischung fuer jedes Pixel zu berechnen.</p>"},{"location":"anleitung/kalibrierung/#was-wird-benoetigt","title":"Was wird benoetigt?","text":"Material / Werkzeug Beschreibung Transparente Filamente Mindestens Cyan, Magenta, Gelb und Weiss. Weitere Farben optional. 3D-Drucker Mit 0.2mm-Duese und 0.10mm-Schichthoehe konfiguriert Lichtquelle LED-Panel oder Fenster mit Tageslicht (~6000K, gleichmaessig) Bildbearbeitungsprogramm Paint, GIMP, Photoshop oder aehnlich -- mit Pipetten-Werkzeug Web-Farbkonverter convertacolor.com oder ein vergleichbares Tool <p>Empfehlung</p> <p>Ein LED-Panel liefert die gleichmaessigsten Ergebnisse. Wenn du ein Fenster verwendest, waehle einen bewoelkten Tag, um direktes Sonnenlicht zu vermeiden.</p>"},{"location":"anleitung/kalibrierung/#schritt-1-testmuster-drucken","title":"Schritt 1: Testmuster drucken","text":"<p>Drucke Farb-Teststreifen mit 1 bis 5 Schichten fuer jede Filamentfarbe. Jeder Streifen sollte gross genug sein, um spaeter eine saubere Farbmessung durchfuehren zu koennen (mindestens 10 x 10 mm pro Feld).</p>"},{"location":"anleitung/kalibrierung/#automatisch-mit-pixestl-empfohlen","title":"Automatisch mit PIXEstL (empfohlen)","text":"<p>PIXEstL kann die Kalibrierungs-Testmuster direkt aus deiner Palette generieren:</p> <pre><code>pixestl --calibrate -p palette/filament-palette-0.10mm.json -o kalibrierung.zip --color-layers 5\n</code></pre> <p>Dieser Befehl erzeugt:</p> <ul> <li>Fuer jedes aktive Filament eine Reihe mit 5 Testquadraten (10 x 10 mm)</li> <li>Jedes Quadrat hat die exakte Dicke fuer 1, 2, 3, 4 bzw. 5 Schichten</li> <li>Separate STL-Dateien pro Filament (fuer korrekte Filamentzuordnung im Slicer)</li> <li>Eine Grundplatte als Basis</li> </ul> <p>7-Schicht-Kalibrierung</p> <p>Fuer eine feinere Kalibrierung mit 7 Schichten: <pre><code>pixestl --calibrate -p palette.json -o kalibrierung.zip --color-layers 7\n</code></pre></p>"},{"location":"anleitung/kalibrierung/#manuell-erstellen","title":"Manuell erstellen","text":"<p>Alternativ kann das Testmuster manuell in einem CAD-Programm erstellt werden. Wichtig ist, dass jedes Feld eine exakte Anzahl von Schichten enthaelt:</p> Feld Schichten Dicke bei 0.10mm 1 1 Schicht 0.10 mm 2 2 Schichten 0.20 mm 3 3 Schichten 0.30 mm 4 4 Schichten 0.40 mm 5 5 Schichten 0.50 mm <p></p> <p>Druckeinstellungen</p> <p>Verwende exakt die gleiche Schichthoehe wie spaeter beim Lithophanie-Druck (Standard: 0.10mm). Setze Infill auf 100%, damit die Schichten vollstaendig gefuellt sind.</p>"},{"location":"anleitung/kalibrierung/#schritt-2-testmuster-fotografieren","title":"Schritt 2: Testmuster fotografieren","text":"<p>Halte die gedruckten Teststreifen gegen eine gleichmaessige Hintergrundbeleuchtung und fotografiere sie. Die Beleuchtung muss konstant und gleichmaessig sein, damit die gemessenen Farbwerte reproduzierbar bleiben.</p> <p>Wichtig bei der Aufnahme:</p> <ul> <li>Verwende ein LED-Panel oder ein gleichmaessig helles Fenster (~6000K Farbtemperatur)</li> <li>Halte die Teststreifen direkt vor die Lichtquelle</li> <li>Vermeide Reflexionen und Schatten auf den Testfeldern</li> <li>Fotografiere alle Farben unter identischen Lichtbedingungen</li> <li>Verwende den manuellen Weissabgleich deiner Kamera, wenn moeglich</li> </ul> <p>Konsistente Beleuchtung</p> <p>Aendere die Beleuchtung zwischen den einzelnen Farben nicht. Wenn du die Position oder Helligkeit der Lichtquelle aenderst, werden die gemessenen Werte inkonsistent und die Farbwiedergabe leidet.</p>"},{"location":"anleitung/kalibrierung/#schritt-3-hsl-werte-messen","title":"Schritt 3: HSL-Werte messen","text":"<p>Oeffne das Foto in einem Bildbearbeitungsprogramm und bestimme die HSL-Werte fuer jedes Testfeld. Der folgende Workflow zeigt die fuenf Schritte anhand eines konkreten Beispiels:</p> <p></p> <p>Die fuenf nummerierten Schritte im Detail:</p> <ol> <li>Pipette auswaehlen -- Waehle das Pipetten-Werkzeug (Eyedropper / Farbaufnahme) in deinem Bildbearbeitungsprogramm aus.</li> <li>Farbe aufnehmen -- Klicke auf ein Farbfeld des gedruckten Teststreifens im Foto. Waehle die Mitte des Feldes, um Randeffekte zu vermeiden.</li> <li>Farbwerte ablesen -- Oeffne den Farbwaehler (Color Picker), um die RGB-Werte der aufgenommenen Farbe zu sehen. Notiere den Hex-Code (z.B. <code>#4ABCE8</code>).</li> <li>Hex-Code umrechnen -- Gib den Hex-Code auf convertacolor.com ein, um ihn in HSL umzurechnen.</li> <li>HSL-Werte notieren -- Lies die drei HSL-Werte ab: H (Hue / Farbton, 0-360), S (Saturation / Saettigung, 0-100) und L (Lightness / Helligkeit, 0-100).</li> </ol> <p>Wiederhole diesen Vorgang fuer jedes Testfeld (1-5 Schichten) und jede Filamentfarbe.</p> <p>Genauere Messungen</p> <p>Messe jeden Farbwert an mehreren Stellen innerhalb des Feldes und bilde den Mittelwert. Das gleicht Ungleichmaessigkeiten im Druck und in der Beleuchtung aus.</p>"},{"location":"anleitung/kalibrierung/#schritt-4-palette-json-erstellen","title":"Schritt 4: Palette-JSON erstellen","text":"<p>Trage die gemessenen HSL-Werte fuer jede Schichtanzahl (1-5) und jede Farbe in die Palette-JSON-Datei ein. Jeder Eintrag besteht aus einem Hex-Schluessel, einem Namen, einem Aktivierungsflag und den HSL-Werten fuer bis zu 5 Schichten.</p> <p>Hier ein vollstaendiges Beispiel fuer Cyan:</p> <pre><code>{\n  \"#0086D6\": {\n    \"name\": \"Cyan[PLA Basic]\",\n    \"active\": true,\n    \"layers\": {\n      \"1\": {\n        \"H\": 201.9,\n        \"S\": 96.4,\n        \"L\": 78.2\n      },\n      \"2\": {\n        \"H\": 199.5,\n        \"S\": 100,\n        \"L\": 64.3\n      },\n      \"3\": {\n        \"H\": 199.8,\n        \"S\": 91.5,\n        \"L\": 53.9\n      },\n      \"4\": {\n        \"H\": 200.6,\n        \"S\": 95.9,\n        \"L\": 47.6\n      },\n      \"5\": {\n        \"H\": 203.8,\n        \"S\": 99.1,\n        \"L\": 45.3\n      }\n    }\n  }\n}\n</code></pre> <p>So liest du die Werte:</p> <ul> <li>Schicht 1 (duennste Schicht): Hellster Wert, hohe Lightness (L), da wenig Filament das Licht nur leicht faerbt.</li> <li>Schicht 5 (dickste Schicht): Dunkelster/saetttigster Wert, niedrige Lightness (L), da mehr Filament mehr Licht absorbiert.</li> <li>Hue (H) bleibt typischerweise relativ konstant ueber alle Schichten.</li> <li>Saturation (S) steigt meist mit zunehmender Schichtanzahl.</li> <li>Lightness (L) sinkt mit zunehmender Schichtanzahl.</li> </ul> <p>Vollst\u00e4ndige Palette</p> <p>Eine vollst\u00e4ndige Palette enth\u00e4lt Eintr\u00e4ge f\u00fcr alle verwendeten Filamentfarben, einschlie\u00dflich Wei\u00df. Details zum Palette-Format findest du unter Palette-Format.</p>"},{"location":"anleitung/kalibrierung/#tipps-fuer-bessere-ergebnisse","title":"Tipps fuer bessere Ergebnisse","text":"<ul> <li>Konsistente Hintergrundbeleuchtung verwenden -- Das Ergebnis steht und faellt mit der Beleuchtung. Ein LED-Panel mit 6000K Farbtemperatur liefert die besten Resultate.</li> <li>Mehrfach messen -- Nimm jeden Farbwert an 3-5 verschiedenen Stellen des Testfeldes auf und bilde den Mittelwert. Dies reduziert Messfehler.</li> <li>Im abgedunkelten Raum kalibrieren -- Fremdlicht verfaelscht die Farbwerte. Schalte Deckenleuchten aus und verdunkle Fenster, soweit moeglich.</li> <li>Testdrucke beschriften -- Notiere auf jedem Teststreifen Filamentname, Hersteller und Schichthoehe. So kannst du spaeter nachvollziehen, welche Werte zu welchem Filament gehoeren.</li> <li>Kamera-Weissabgleich fixieren -- Verwende den manuellen Weissabgleich deiner Kamera, um Farbverschiebungen durch den Automatik-Modus zu vermeiden.</li> <li>Gleiche Schichthoehe verwenden -- Die Kalibrierung gilt nur fuer die Schichthoehe, mit der kalibriert wurde. Wenn du von 0.10mm auf 0.08mm wechselst, muss neu kalibriert werden.</li> </ul> <p>Kalibrierung pro Schichthoehe</p> <p>Die HSL-Werte aendern sich bei unterschiedlichen Schichthoehen. Eine bei 0.10mm kalibrierte Palette liefert bei 0.08mm oder 0.12mm ungenaue Ergebnisse. Kalibriere fuer jede Schichthoehe separat.</p>"},{"location":"anleitung/kalibrierung/#nachste-schritte","title":"N\u00e4chste Schritte","text":"<ul> <li>Palette-Format \u2192 \u2013 Detaillierte Beschreibung der JSON-Struktur</li> <li>Bild vorbereiten \u2192 \u2013 Welches Foto eignet sich am besten?</li> <li>Lithophanie generieren \u2192 \u2013 Die kalibrierte Palette verwenden</li> </ul>"},{"location":"anleitung/palette/","title":"Palette-Format","text":"<p>Die Palette-Datei definiert, wie jede Filamentfarbe bei unterschiedlichen Schichtdicken aussieht, wenn Licht hindurchscheint. PIXEstL nutzt diese Informationen, um die optimale Farbmischung fuer jedes Pixel der Lithophanie zu berechnen.</p>"},{"location":"anleitung/palette/#uebersicht","title":"Uebersicht","text":"<p>Die Palette ist eine JSON-Datei, in der jede Filamentfarbe als eigener Eintrag gespeichert ist. Jeder Eintrag enthaelt die gemessenen HSL-Werte (Farbton, Saettigung, Helligkeit) fuer 1 bis 5 uebereinanderliegende Schichten des Filaments. Dadurch kann PIXEstL berechnen, wie eine Farbe bei unterschiedlicher Dicke wirkt -- von einer einzelnen duennen Schicht bis zu fuenf gestapelten Schichten.</p> <p>Das Projekt enthaelt eine vorkalibrierte Beispiel-Palette:</p> <pre><code>palette/filament-palette-0.10mm.json\n</code></pre> <p>Diese Datei ist auf Bambu Lab PLA Basic und PLA Matte Filamente bei 0.10mm Schichthoehe kalibriert.</p>"},{"location":"anleitung/palette/#json-struktur","title":"JSON-Struktur","text":"<p>Die Palette besteht aus einem JSON-Objekt, dessen Schluessel die Hex-Farbcodes der Filamente sind. Jeder Eintrag hat folgende Struktur:</p> <pre><code>{\n  \"#0086D6\": {\n    \"name\": \"Cyan[PLA Basic]\",\n    \"active\": true,\n    \"layers\": {\n      \"1\": {\n        \"H\": 201.9,\n        \"S\": 96.4,\n        \"L\": 78.2\n      },\n      \"2\": {\n        \"H\": 199.5,\n        \"S\": 100,\n        \"L\": 64.3\n      },\n      \"3\": {\n        \"H\": 199.8,\n        \"S\": 91.5,\n        \"L\": 53.9\n      },\n      \"4\": {\n        \"H\": 200.6,\n        \"S\": 95.9,\n        \"L\": 47.6\n      },\n      \"5\": {\n        \"H\": 203.8,\n        \"S\": 99.1,\n        \"L\": 45.3\n      }\n    }\n  }\n}\n</code></pre> <p>Die Schichten sind von <code>\"1\"</code> (duennste, hellste Schicht) bis <code>\"5\"</code> (dickste, dunkelste/saettigste Schicht) nummeriert.</p>"},{"location":"anleitung/palette/#felder-erklaert","title":"Felder erklaert","text":"Feld Typ Beschreibung Hex-Key String Eindeutiger Schluessel fuer die Farbe im Format <code>\"#RRGGBB\"</code>, z.B. <code>\"#0086D6\"</code>. Dient als Identifikator und wird im Slicer zur Filamentzuordnung verwendet. name String Lesbarer Name des Filaments, z.B. <code>\"Cyan[PLA Basic]\"</code>. Wird fuer die Benennung der STL-Dateien in der Ausgabe verwendet. active Boolean <code>true</code> = Farbe wird bei der Generierung beruecksichtigt. <code>false</code> = Farbe wird ignoriert. layers Object Objekt mit den Schluesseln <code>\"1\"</code> bis <code>\"5\"</code>. Jeder Schluessel enthaelt ein Objekt mit den HSL-Werten fuer die entsprechende Schichtanzahl. H Zahl Hue (Farbton) in Grad, Bereich 0-360. Rot = 0, Gruen = 120, Blau = 240. S Zahl Saturation (Saettigung) in Prozent, Bereich 0-100. 0 = Grau, 100 = volle Saettigung. L Zahl Lightness (Helligkeit) in Prozent, Bereich 0-100. 0 = Schwarz, 50 = reine Farbe, 100 = Weiss. <p>Weniger als 5 Schichten</p> <p>Nicht jede Farbe benoetigt alle 5 Schichten. Opake Farben wie Schwarz koennen mit weniger Schichten definiert werden. Beispielsweise hat Schwarz in der Beispiel-Palette nur die Schichten 4 und 5, da bei weniger Schichten kaum Schwarz sichtbar wird.</p>"},{"location":"anleitung/palette/#weiss-filament","title":"Weiss-Filament","text":"<p>Weiss ist die einzige zwingend erforderliche Farbe in jeder Palette. Es dient als Fuellmaterial fuer die additive Farbmischung. An Stellen, wo ein Pixel weniger als 5 Farbschichten benoetigt, fuellt Weiss die verbleibenden Schichten auf.</p> <p>Weiss ist Pflicht</p> <p>Ohne einen Weiss-Eintrag in der Palette kann PIXEstL die Farbmischung nicht korrekt berechnen. Viele helle Farben und Pastelltoene sind ohne Weiss-Fuellschichten nicht darstellbar.</p> <p>Beispiel-Eintrag fuer Weiss:</p> <pre><code>{\n  \"#FFFFFF\": {\n    \"name\": \"White[PLA Basic]\",\n    \"active\": true,\n    \"layers\": {\n      \"1\": {\n        \"H\": 0,\n        \"S\": 0,\n        \"L\": 95\n      },\n      \"2\": {\n        \"H\": 0,\n        \"S\": 0,\n        \"L\": 95\n      },\n      \"3\": {\n        \"H\": 0,\n        \"S\": 0,\n        \"L\": 85\n      },\n      \"4\": {\n        \"H\": 0,\n        \"S\": 0,\n        \"L\": 85\n      },\n      \"5\": {\n        \"H\": 0,\n        \"S\": 0,\n        \"L\": 85\n      }\n    }\n  }\n}\n</code></pre> <p>Bei Weiss ist der Hue (H) und die Saettigung (S) jeweils 0. Nur die Helligkeit (L) variiert leicht je nach Schichtanzahl, da auch weisses Filament bei mehr Schichten etwas dunkler wird.</p>"},{"location":"anleitung/palette/#farben-aktivieren-und-deaktivieren","title":"Farben aktivieren und deaktivieren","text":"<p>Mit dem Feld <code>\"active\"</code> kannst du einzelne Farben ein- oder ausschalten, ohne sie aus der Palette zu loeschen:</p> <pre><code>{\n  \"#FFE34F\": {\n    \"name\": \"Pale yellow[OVERTURE]\",\n    \"active\": false,\n    \"layers\": { ... }\n  }\n}\n</code></pre> <p>Wann deaktivieren?</p> <ul> <li>Filament nicht vorraetig: Du hast eine Farbe kalibriert, aber das Filament ist gerade leer.</li> <li>Testweise ausschliessen: Du moechtest pruefen, wie die Lithophanie ohne eine bestimmte Farbe aussieht.</li> <li>AMS-Beschraenkung: Dein AMS hat nur 4 Slots, aber deine Palette enthaelt 8 Farben. Deaktiviere die Farben, die nicht geladen sind.</li> </ul> <p>Deaktivierte Farben bleiben in der Datei erhalten und koennen jederzeit durch Setzen von <code>\"active\": true</code> wieder verwendet werden.</p>"},{"location":"anleitung/palette/#eigene-palette-erstellen","title":"Eigene Palette erstellen","text":"<p>So erstellst du eine eigene Palette fuer deine Filamente:</p> <ol> <li> <p>Beispiel-Palette kopieren:</p> <pre><code>cp palette/filament-palette-0.10mm.json palette/meine-palette.json\n</code></pre> </li> <li> <p>Kalibrierung durchfuehren: Drucke Teststreifen und messe die HSL-Werte wie unter Filament-Kalibrierung beschrieben.</p> </li> <li> <p>Werte eintragen: Ersetze die HSL-Werte in der kopierten Datei durch deine gemessenen Werte. Passe den <code>name</code> an, um deine Filamente zu kennzeichnen.</p> </li> <li> <p>Nicht vorhandene Farben deaktivieren: Setze <code>\"active\": false</code> fuer alle Farben, die du nicht besitzt oder nicht kalibriert hast.</p> </li> <li> <p>Neue Farben hinzufuegen: Fuege weitere Farbeintraege nach dem gleichen Schema hinzu. Waehle einen passenden Hex-Code als Schluessel.</p> </li> <li> <p>Palette verwenden:</p> <pre><code>pixestl -i bild.jpg -p palette/meine-palette.json -o ausgabe.zip -w 100\n</code></pre> </li> </ol> <p>Palette benennen</p> <p>Verwende die Schichthoehe im Dateinamen (z.B. <code>meine-palette-0.10mm.json</code>), um Verwechslungen zu vermeiden, wenn du Paletten fuer verschiedene Schichthoehen anlegst.</p>"},{"location":"anleitung/palette/#beispiel-palette","title":"Beispiel-Palette","text":"<p>Das Projekt enthaelt eine vollstaendige Beispiel-Palette unter:</p> <pre><code>palette/filament-palette-0.10mm.json\n</code></pre> <p>Diese Palette enthaelt Eintraege fuer die folgenden Filamente (aktive Farben):</p> Hex-Code Name Aktiv <code>#0086D6</code> Cyan[PLA Basic] Ja <code>#EC008C</code> Magenta[PLA Basic] Ja <code>#FCE300</code> Yellow[PLA Basic] Ja <code>#FFFFFF</code> White[PLA Basic] Ja <code>#000000</code> Black[PLA Basic] Ja <code>#E7CEB5</code> Beige[PLA Basic] Ja <code>#8BD5EE</code> Matte Ice Blue[PLA Matte] Ja <code>#E4BDD0</code> Matte Sakura Pink[PLA Matte] Ja <p>Zusaetzlich sind zahlreiche weitere Farben enthalten (z.B. Purple, Silver, Green, Orange), die jedoch auf <code>\"active\": false</code> gesetzt sind und erst nach Kalibrierung aktiviert werden koennen.</p>"},{"location":"anleitung/palette/#alternative-formate","title":"Alternative Formate","text":"<p>Neben der ausfuehrlichen HSL-Notation koennen Schichten auch als Hex-Strings definiert werden. PIXEstL konvertiert diese automatisch in HSL-Werte:</p> <pre><code>{\n  \"#FF5500\": {\n    \"name\": \"Orange[Beispiel]\",\n    \"active\": true,\n    \"layers\": {\n      \"1\": \"#FFD4B0\",\n      \"2\": \"#FFB87A\",\n      \"3\": \"#FF9C4A\",\n      \"4\": \"#FF7B1A\",\n      \"5\": \"#FF5500\"\n    }\n  }\n}\n</code></pre> <p>In diesem Format wird jeder Schicht direkt ein Hex-Farbwert zugewiesen, anstatt die einzelnen HSL-Komponenten anzugeben. Die Hex-Strings werden beim Laden der Palette automatisch in H-, S- und L-Werte umgerechnet.</p> <p>HSL bevorzugt</p> <p>Das HSL-Format bietet mehr Kontrolle und laesst sich leichter manuell anpassen. Die Hex-String-Variante ist praktisch, wenn du Farbwerte direkt aus einem Farbwaehler kopieren moechtest, ohne sie vorher umzurechnen.</p> <p>Palette pruefen</p> <p>Verwende <code>pixestl --palette-info -p deine-palette.json</code> um zu pruefen, welche Filamente aktiv sind, wie viele Farbkombinationen erzeugt werden und ob Layer-Definitionen fehlen.</p>"},{"location":"anleitung/palette/#naechste-schritte","title":"Naechste Schritte","text":"<ul> <li>Filament-Kalibrierung -- HSL-Werte fuer eigene Filamente messen</li> <li>Best Practices -- Tipps und Tricks fuer bessere Ergebnisse</li> <li>Lithophanie generieren -- Die Palette im Generierungsprozess verwenden</li> </ul>"},{"location":"anleitung/slicer/","title":"Slicer-Einrichtung (Bambu Studio)","text":"<p>Diese Anleitung erklaert Schritt fuer Schritt, wie du die von PIXEstL erzeugten STL-Dateien in Bambu Studio einrichtest und fuer den Druck vorbereitest.</p>"},{"location":"anleitung/slicer/#voraussetzungen","title":"Voraussetzungen","text":"<ul> <li>[x] Bambu Studio ist installiert (Version 1.8 oder neuer empfohlen)</li> <li>[x] Die PIXEstL-Ausgabe-ZIP wurde entpackt (alle STL-Dateien liegen in einem Ordner)</li> <li>[x] Ein 3D-Drucker mit AMS (Automatic Material System) oder der Moeglichkeit zum manuellen Filamentwechsel</li> </ul>"},{"location":"anleitung/slicer/#schritt-1-stl-dateien-importieren","title":"Schritt 1: STL-Dateien importieren","text":"<ol> <li>Oeffne Bambu Studio</li> <li>Gehe zu File &gt; Import und waehle alle STL-Dateien aus dem entpackten Ordner aus</li> </ol> <ol> <li>Bambu Studio fragt: \"Load these files as a single object with multiple parts?\" -- Klicke auf Yes</li> </ol> <p>Warum als einzelnes Objekt?</p> <p>Die STL-Dateien repraesentieren verschiedene Farbschichten, die exakt uebereinander liegen muessen. Durch das Laden als einzelnes Objekt mit mehreren Teilen bleiben die Positionen korrekt.</p>"},{"location":"anleitung/slicer/#schritt-2-filamente-zuweisen","title":"Schritt 2: Filamente zuweisen","text":"<p>Im Objects Panel (linke Seitenleiste) siehst du jede Farbschicht als separaten Eintrag. Jeder Eintrag hat ein farbiges Quadrat, das das zugeordnete Filament anzeigt.</p> <ol> <li>Klicke auf das farbige Quadrat neben jeder Schicht</li> <li>Weise das passende Filament zu:</li> </ol> STL-Datei Filament-Slot <code>layer-Cyan[...].stl</code> Cyan-Filament <code>layer-Magenta[...].stl</code> Magenta-Filament <code>layer-Yellow[...].stl</code> Gelb-Filament <code>layer-White[...].stl</code> Weiss-Filament (Slot 1) <code>layer-plate.stl</code> Weiss-Filament (Slot 1) <code>layer-texture-[...].stl</code> Weiss-Filament (Slot 1) <p></p> <p>Gleicher Slot fuer Platte, Weiss und Textur</p> <p>Die Dateien <code>layer-plate</code>, <code>layer-White</code> und <code>layer-texture</code> muessen alle demselben Filament-Slot zugewiesen werden (Slot 1 = Weiss). Diese Schichten bilden zusammen die Basis und Oberflaeche der Lithophanie.</p>"},{"location":"anleitung/slicer/#schritt-3-druckparameter-einstellen","title":"Schritt 3: Druckparameter einstellen","text":"<p>Stelle die folgenden Parameter in Bambu Studio ein:</p> Parameter Wert Hinweis Drucker Bambu Lab X1C mit 0.2mm Duese Andere Bambu-Modelle funktionieren ebenfalls Druckprofil 0.10mm Standard Feinere Schichthoehe = bessere Farbmischung Wall Loops 4 Sorgt fuer stabile Aussenwaende Top/Bottom Shell Layers 7 Solide Ober- und Unterseite Infill Density 100% KRITISCH -- siehe Warnung unten Infill Pattern Rectilinear Standard-Fuellmuster <p>Infill MUSS 100% sein!</p> <p>Lithophanien funktionieren nur mit 100% Infill. Bei weniger als 100% werden die Farben nicht korrekt dargestellt, da das Licht durch die Hohlraeume unkontrolliert durchscheint. Ausserdem wird die Lithophanie strukturell instabil und kann beim Herausloesen vom Druckbett brechen.</p>"},{"location":"anleitung/slicer/#schritt-4-filament-reihenfolge-konfigurieren","title":"Schritt 4: Filament-Reihenfolge konfigurieren","text":"<p>Die Reihenfolge, in der die Filamente gedruckt werden, ist entscheidend fuer das Farbergebnis.</p> <ol> <li>Oeffne die Plate Settings (unten links im Bedienfeld)</li> <li>Setze Print Sequence auf <code>By layer</code></li> <li>Setze Other layers filament sequence auf <code>Customize</code></li> </ol> <p></p> <ol> <li>Konfiguriere die Filament-Reihenfolge ab Layer 7 bis Ende:</li> </ol> <pre><code>Filament-Reihenfolge: 1 \u2192 2 \u2192 3 \u2192 4\n</code></pre> <p></p> <p>Warum ab Layer 7?</p> <p>Die ersten 6 Schichten bestehen aus der Grundplatte und der weissen Basis. Ab Layer 7 beginnen die eigentlichen Farbschichten. Die Reihenfolge <code>1 \u2192 2 \u2192 3 \u2192 4</code> bestimmt, in welcher Abfolge die Farben pro Schicht aufgetragen werden.</p>"},{"location":"anleitung/slicer/#schritt-5-ams-pausen-konfigurieren-optional","title":"Schritt 5: AMS-Pausen konfigurieren (optional)","text":"<p>Dieser Schritt ist nur noetig, wenn du mehr als 4 Farben verwendest und nur ein einzelnes AMS (4 Slots) zur Verfuegung hast.</p> <ol> <li>Nutze den Layer-Slider auf der rechten Seite der Druckvorschau</li> <li>Navigiere zur Uebergangsschicht, an der die naechste Farbgruppe beginnt</li> <li>Rechtsklicke auf den Slider an dieser Position</li> <li>Waehle \"Add Pause\" aus dem Kontextmenue</li> </ol> <p></p> <p>Bei der Pause haelt der Drucker an, sodass du die Filamente im AMS gegen die naechste Farbgruppe tauschen kannst. Danach den Druck ueber das Display oder Bambu Handy fortsetzen.</p> <p>Mehrere AMS-Einheiten</p> <p>Wenn du ueber ein AMS Hub mit mehreren AMS-Einheiten verfuegst (8 oder 16 Slots), kannst du alle Farben gleichzeitig laden und benoetigst keine Pausen.</p>"},{"location":"anleitung/slicer/#andere-slicer","title":"Andere Slicer","text":"<p>Die gleichen Prinzipien gelten auch fuer andere Slicer wie OrcaSlicer, PrusaSlicer oder Cura:</p> <ol> <li>Alle STL-Dateien als Multi-Part-Objekt importieren -- die Teile muessen als ein Objekt mit mehreren Koerpern geladen werden</li> <li>Filamente korrekt zuweisen -- jede Farbschicht dem passenden Filament zuordnen</li> <li>100% Infill einstellen -- ohne Ausnahme</li> <li>Filament-Reihenfolge konfigurieren -- sofern der Slicer diese Option bietet</li> </ol> <p>OrcaSlicer</p> <p>OrcaSlicer basiert auf Bambu Studio und bietet nahezu identische Einstellungsmoeglichkeiten. Die oben beschriebenen Schritte lassen sich direkt uebertragen.</p>"},{"location":"anleitung/slicer/#naechste-schritte","title":"Naechste Schritte","text":"<ul> <li>Drucken &amp; Nachbearbeitung -- Tipps zum Druckvorgang und zur Hintergrundbeleuchtung</li> </ul>"},{"location":"anleitung/uebersicht/","title":"Anleitung \u2013 \u00dcbersicht","text":"<p>Hier bekommst du einen schnellen \u00dcberblick \u00fcber den kompletten Workflow von PIXEstL \u2013 von der Idee bis zum fertigen Leuchtbild.</p>"},{"location":"anleitung/uebersicht/#der-weg-zur-fertigen-lithophanie","title":"Der Weg zur fertigen Lithophanie","text":"<pre><code>graph LR\n    A[\"\ud83d\udcf7 Foto w\u00e4hlen\"] --&gt; B[\"\ud83c\udfa8 Palette kalibrieren\"]\n    B --&gt; C[\"\u2699\ufe0f PIXEstL ausf\u00fchren\"]\n    C --&gt; D[\"\ud83d\udda8\ufe0f Slicer einrichten\"]\n    D --&gt; E[\"\u2705 Drucken &amp; beleuchten\"]</code></pre> <p>Jeder Schritt baut auf dem vorherigen auf. Beim ersten Mal gehst du alle Schritte durch \u2013 danach brauchst du die Kalibrierung nur noch selten wiederholen.</p>"},{"location":"anleitung/uebersicht/#die-5-schritte-im-detail","title":"Die 5 Schritte im Detail","text":""},{"location":"anleitung/uebersicht/#1-palette-kalibrieren","title":"1. Palette kalibrieren","text":"<p>Was passiert: Du druckst kleine Testquadrate aus deinen Filamenten, fotografierst sie hinterleuchtet und misst die Farben. Diese Werte tr\u00e4gst du in eine JSON-Datei ein \u2013 das ist deine pers\u00f6nliche \"Farbkarte\" f\u00fcr PIXEstL.</p> <p>Warum wichtig: Jedes Filament sieht hinterleuchtet anders aus \u2013 auch Filamente gleicher Farbe von unterschiedlichen Herstellern. Ohne Kalibrierung stimmen die Farben der fertigen Lithophanie oft nicht mit dem Originalbild \u00fcberein.</p> <p>Typische Dauer: ~30\u201360 Minuten beim ersten Mal (Druck + Foto + Werte eintragen). Einmalige Arbeit \u2013 die Palette gilt dann dauerhaft.</p> <p>Zur Kalibrierungs-Anleitung \u2192</p>"},{"location":"anleitung/uebersicht/#2-bild-vorbereiten","title":"2. Bild vorbereiten","text":"<p>Was passiert: Du w\u00e4hlst ein Foto aus und bereitest es optional kurz vor \u2013 Ausschnitt w\u00e4hlen, Kontrast anpassen, auf eine sinnvolle Gr\u00f6\u00dfe skalieren.</p> <p>Warum wichtig: Nicht jedes Bild eignet sich gleich gut als Lithophanie. Bilder mit gutem Kontrast und klaren Details sehen am besten aus.</p> <p>Typische Dauer: 5\u201310 Minuten.</p> <p>Zur Seite Bild vorbereiten \u2192</p>"},{"location":"anleitung/uebersicht/#3-pixestl-ausfuhren","title":"3. PIXEstL ausf\u00fchren","text":"<p>Was passiert: Ein einzelner Befehl in der Kommandozeile \u2013 PIXEstL liest dein Bild und die Palette und erzeugt eine ZIP-Datei mit mehreren STL-Dateien.</p> <p>Warum mehrere STL-Dateien? Jede Datei entspricht einer Farbschicht (Cyan, Magenta, Gelb, Wei\u00df). Diese Schichten werden sp\u00e4ter \u00fcbereinandergedruckt.</p> <p>Typische Dauer: 5\u201330 Sekunden (abh\u00e4ngig von Bildgr\u00f6\u00dfe und Einstellungen).</p> <p>Zur Generierungs-Anleitung \u2192</p>"},{"location":"anleitung/uebersicht/#4-slicer-einrichten","title":"4. Slicer einrichten","text":"<p>Was passiert: Du l\u00e4dst alle STL-Dateien in Bambu Studio, weist jeder Datei das richtige Filament zu und stellst die Druckparameter ein (wichtigste: 100% Infill).</p> <p>Warum wichtig: Nur wenn jede Schicht aus dem richtigen Filament besteht, entstehen die korrekten Farben. Falsche Zuordnung ist der h\u00e4ufigste Fehler.</p> <p>Typische Dauer: 10\u201315 Minuten.</p> <p>Zur Slicer-Anleitung \u2192</p>"},{"location":"anleitung/uebersicht/#5-drucken-beleuchten","title":"5. Drucken &amp; beleuchten","text":"<p>Was passiert: Der Drucker druckt die Lithophanie \u2013 das dauert je nach Gr\u00f6\u00dfe 3\u20138 Stunden. Danach h\u00e4ltst du sie einfach vor eine helle Lichtquelle.</p> <p>Warum Hintergrundbeleuchtung? Eine Lithophanie ist undurchsichtig, solange kein Licht von hinten kommt. Erst die Beleuchtung macht das Bild sichtbar und l\u00e4sst die Farben aufleuchten.</p> <p>Typische Dauer: 3\u20138 Stunden Druckzeit.</p> <p>Zur Drucken-Anleitung \u2192</p>"},{"location":"anleitung/uebersicht/#nachster-schritt","title":"N\u00e4chster Schritt","text":"<p>Bereit? Dann starte mit der Palette kalibrieren \u2192</p> <p>Oder wenn du erstmal schnell ein Ergebnis sehen m\u00f6chtest, nutze die bereits kalibrierte Beispiel-Palette und gehe direkt zum Schnellstart \u2192.</p>"},{"location":"installation/unix/","title":"Installation unter macOS / Linux","text":"<p>Diese Anleitung f\u00fchrt dich Schritt f\u00fcr Schritt durch die Installation von PIXEstL auf macOS oder Linux.</p>"},{"location":"installation/unix/#was-du-brauchst","title":"Was du brauchst","text":"<ul> <li>macOS 11+ oder eine aktuelle Linux-Distribution (Ubuntu, Fedora, Arch, \u2026)</li> <li>Terminal-Zugang</li> <li>Internetverbindung</li> <li>Etwa 500 MB freier Speicherplatz</li> </ul>"},{"location":"installation/unix/#schritt-1-rust-installieren","title":"Schritt 1: Rust installieren","text":"<p>PIXEstL ist in der Programmiersprache Rust geschrieben. Du musst Rust einmalig installieren.</p> <p>\u00d6ffne ein Terminal und f\u00fchre aus:</p> <pre><code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n</code></pre> <p>Der Installer fragt nach deinen Pr\u00e4ferenzen \u2013 einfach Enter dr\u00fccken f\u00fcr die Standardinstallation.</p> <p>Danach musst du die Umgebungsvariablen neu laden:</p> <pre><code>source ~/.cargo/env\n</code></pre> <p>Was wird installiert?</p> <p>Rustup installiert <code>rustc</code> (Compiler) und <code>cargo</code> (Paketmanager) in deinem Home-Verzeichnis (<code>~/.cargo/</code>). Keine Root-Rechte n\u00f6tig.</p> <p>Installation pr\u00fcfen:</p> <pre><code>rustc --version\ncargo --version\n</code></pre> <p>Du solltest etwas wie <code>rustc 1.75.0</code> sehen.</p>"},{"location":"installation/unix/#schritt-2-git-prufen","title":"Schritt 2: Git pr\u00fcfen","text":"<p>Git ist auf den meisten Systemen bereits vorinstalliert:</p> <pre><code>git --version\n</code></pre> <p>Falls nicht, installiere es:</p> Ubuntu / DebianFedora / RHELArch LinuxmacOS (Homebrew) <pre><code>sudo apt install git\n</code></pre> <pre><code>sudo dnf install git\n</code></pre> <pre><code>sudo pacman -S git\n</code></pre> <pre><code>brew install git\n</code></pre>"},{"location":"installation/unix/#schritt-3-pixestl-herunterladen","title":"Schritt 3: PIXEstL herunterladen","text":"<pre><code>git clone https://github.com/feurer98/PIXEstL.git\ncd PIXEstL/rust\n</code></pre>"},{"location":"installation/unix/#schritt-4-pixestl-bauen","title":"Schritt 4: PIXEstL bauen","text":"<pre><code>cargo build --release\n</code></pre> <p>Was macht dieser Befehl?</p> <p><code>cargo build --release</code> kompiliert PIXEstL mit allen Optimierungen (Link-Time-Optimization aktiv). Das Ergebnis ist eine einzelne ausf\u00fchrbare Datei ohne weitere Abh\u00e4ngigkeiten.</p> <p>Der erste Build dauert 1\u20133 Minuten, da alle Abh\u00e4ngigkeiten heruntergeladen und kompiliert werden. Folge-Builds sind deutlich schneller.</p> <p>Das fertige Programm liegt unter:</p> <pre><code>PIXEstL/rust/target/release/pixestl\n</code></pre>"},{"location":"installation/unix/#schritt-5-optional-ins-system-path-installieren","title":"Schritt 5: Optional \u2013 ins System-PATH installieren","text":"<p>Damit du <code>pixestl</code> von \u00fcberall aufrufen kannst:</p> <pre><code># Option A: Symlink ins ~/.local/bin (kein sudo n\u00f6tig)\nmkdir -p ~/.local/bin\nln -s \"$(pwd)/target/release/pixestl\" ~/.local/bin/pixestl\n\n# Option B: \u00dcber cargo install (empfohlen)\ncargo install --path .\n</code></pre>"},{"location":"installation/unix/#schritt-6-installation-prufen","title":"Schritt 6: Installation pr\u00fcfen","text":"<pre><code>./target/release/pixestl --help\n</code></pre> <p>Du siehst die Hilfe-Ausgabe mit allen verf\u00fcgbaren Optionen \u2013 die Installation ist abgeschlossen.</p>"},{"location":"installation/unix/#haufige-fehler","title":"H\u00e4ufige Fehler","text":"<code>cargo</code> wird nicht gefunden <p>Ursache: Nach der Rustup-Installation wurde das Terminal nicht neu gestartet oder <code>source ~/.cargo/env</code> nicht ausgef\u00fchrt.</p> <p>L\u00f6sung: <pre><code>source ~/.cargo/env\n# oder Terminal neu \u00f6ffnen\n</code></pre></p> Linker-Fehler: <code>cc</code> not found (Linux) <p>Ursache: Der C-Linker fehlt. Rust ben\u00f6tigt auf Linux einen C-Compiler als Backend.</p> <p>L\u00f6sung: <pre><code># Ubuntu/Debian:\nsudo apt install build-essential\n\n# Fedora:\nsudo dnf install gcc\n\n# Arch:\nsudo pacman -S base-devel\n</code></pre></p> Build schl\u00e4gt auf macOS fehl: Xcode Command Line Tools <p>Ursache: Xcode Command Line Tools sind nicht installiert.</p> <p>L\u00f6sung: <pre><code>xcode-select --install\n</code></pre></p> <code>git clone</code> schl\u00e4gt fehl: SSL-Zertifikat-Fehler <p>Ursache: Unternehmens-Proxy oder veraltete CA-Zertifikate.</p> <p>L\u00f6sung: <pre><code>git config --global http.sslVerify false\n# (nur tempor\u00e4r, auf vertrauensw\u00fcrdigen Netzwerken)\n</code></pre></p>"},{"location":"installation/unix/#nachste-schritte","title":"N\u00e4chste Schritte","text":"<ul> <li>Schnellstart \u2192 \u2013 In 10 Minuten zur ersten Lithophanie</li> <li>Palette kalibrieren \u2192 \u2013 Filamente einmessen f\u00fcr genaue Farben</li> </ul>"},{"location":"installation/windows/","title":"Installation unter Windows","text":"<p>Diese Anleitung f\u00fchrt dich Schritt f\u00fcr Schritt durch die Installation von PIXEstL auf Windows.</p>"},{"location":"installation/windows/#was-du-brauchst","title":"Was du brauchst","text":"<ul> <li>Windows 10 oder Windows 11 (64-Bit)</li> <li>Eine Internetverbindung f\u00fcr den Download</li> <li>Etwa 500 MB freier Speicherplatz</li> </ul>"},{"location":"installation/windows/#schritt-1-rust-installieren","title":"Schritt 1: Rust installieren","text":"<p>PIXEstL ist in der Programmiersprache Rust geschrieben. Du musst Rust einmalig installieren.</p> <ol> <li>\u00d6ffne https://rustup.rs im Browser</li> <li>Lade den Windows-Installer (<code>rustup-init.exe</code>) herunter</li> <li>F\u00fchre die Datei aus und folge dem Installer (einfach Enter dr\u00fccken f\u00fcr die Standardoptionen)</li> <li>Starte danach die Eingabeaufforderung (CMD) neu</li> </ol> <p></p> <p>Was wird installiert?</p> <p>Rustup installiert die Rust-Toolchain (<code>rustc</code>, <code>cargo</code>) und f\u00fcgt sie automatisch zum Systempfad hinzu. Du brauchst keine weiteren Abh\u00e4ngigkeiten.</p> <p>Installation pr\u00fcfen:</p> <pre><code>rustc --version\ncargo --version\n</code></pre> <p>Du solltest etwas wie <code>rustc 1.75.0</code> sehen. Falls nicht, starte die Eingabeaufforderung neu.</p>"},{"location":"installation/windows/#schritt-2-git-installieren-falls-noch-nicht-vorhanden","title":"Schritt 2: Git installieren (falls noch nicht vorhanden)","text":"<p>Falls <code>git</code> noch nicht installiert ist, lade es von https://git-scm.com herunter und installiere es.</p> <p>Pr\u00fcfen:</p> <pre><code>git --version\n</code></pre>"},{"location":"installation/windows/#schritt-3-pixestl-herunterladen","title":"Schritt 3: PIXEstL herunterladen","text":"<p>\u00d6ffne die Git Bash oder die Eingabeaufforderung und f\u00fchre aus:</p> <pre><code>git clone https://github.com/feurer98/PIXEstL.git\ncd PIXEstL\\rust\n</code></pre>"},{"location":"installation/windows/#schritt-4-pixestl-bauen","title":"Schritt 4: PIXEstL bauen","text":"<pre><code>cargo build --release\n</code></pre> <p>Was macht dieser Befehl?</p> <p><code>cargo build --release</code> kompiliert PIXEstL mit allen Optimierungen. Das Ergebnis ist eine einzelne ausf\u00fchrbare Datei (<code>pixestl.exe</code>), die keine weiteren Installationen ben\u00f6tigt.</p> <p>Der erste Build dauert 1\u20133 Minuten, da alle Abh\u00e4ngigkeiten heruntergeladen und kompiliert werden.</p> <p>Das fertige Programm liegt unter:</p> <pre><code>PIXEstL\\rust\\target\\release\\pixestl.exe\n</code></pre>"},{"location":"installation/windows/#schritt-5-installation-prufen","title":"Schritt 5: Installation pr\u00fcfen","text":"<pre><code>.\\target\\release\\pixestl.exe --help\n</code></pre> <p>Du siehst die Hilfe-Ausgabe mit allen verf\u00fcgbaren Optionen \u2013 die Installation ist abgeschlossen.</p>"},{"location":"installation/windows/#haufige-fehler","title":"H\u00e4ufige Fehler","text":"<code>cargo</code> wird nicht gefunden <p>Ursache: Rustup wurde installiert, aber die Eingabeaufforderung wurde danach nicht neu gestartet.</p> <p>L\u00f6sung: Schlie\u00dfe alle Fenster der Eingabeaufforderung und \u00f6ffne sie neu. Dann <code>cargo --version</code> erneut pr\u00fcfen.</p> Linker-Fehler beim Build <p>Ursache: Unter Windows ben\u00f6tigt Rust den Microsoft C++ Build-Toolchain (MSVC).</p> <p>L\u00f6sung: Lade die Visual Studio Build Tools von Microsoft herunter: https://visualstudio.microsoft.com/visual-cpp-build-tools/ W\u00e4hle bei der Installation: \"Desktop-Entwicklung mit C++\". Danach Rust erneut installieren oder <code>rustup update</code> ausf\u00fchren.</p> <code>git clone</code> schl\u00e4gt fehl <p>Ursache: Git ist nicht installiert oder nicht im Systempfad.</p> <p>L\u00f6sung: Git von https://git-scm.com installieren und die Eingabeaufforderung neu starten.</p>"},{"location":"installation/windows/#nachste-schritte","title":"N\u00e4chste Schritte","text":"<ul> <li>Schnellstart \u2192 \u2013 In 10 Minuten zur ersten Lithophanie</li> <li>Palette kalibrieren \u2192 \u2013 Filamente einmessen f\u00fcr genaue Farben</li> </ul>"},{"location":"konzepte/architektur/","title":"Technische Architektur","text":"<p>Diese Seite beschreibt die interne Architektur von PIXEstL fuer Entwickler und technisch Interessierte.</p>"},{"location":"konzepte/architektur/#moduluebersicht","title":"Moduluebersicht","text":"<p>PIXEstL ist in sechs klar getrennte Module aufgeteilt, die jeweils eine spezifische Aufgabe erfuellen:</p> <pre><code>graph TB\n    CLI[\"cli&lt;br/&gt;Kommandozeilen-Interface\"]\n    CLI --&gt; IMG[\"image&lt;br/&gt;Bildverarbeitung\"]\n    CLI --&gt; PAL[\"palette&lt;br/&gt;Farbpaletten\"]\n    CLI --&gt; LITHO[\"lithophane&lt;br/&gt;Mesh-Generierung\"]\n    CLI --&gt; STL[\"stl&lt;br/&gt;STL-Export\"]\n\n    PAL --&gt; COL[\"color&lt;br/&gt;Farbraeume &amp; Distanzen\"]\n    LITHO --&gt; COL\n    LITHO --&gt; PAL\n    LITHO --&gt; IMG</code></pre> Modul Verzeichnis Aufgabe <code>cli</code> <code>src/cli/</code> Kommandozeilen-Parsing mit clap <code>color</code> <code>src/color/</code> Farbraeume (RGB, HSL, CIE-Lab) und Distanzen <code>palette</code> <code>src/palette/</code> Paletten-Laden, Farbkombinationen, Quantisierung <code>image</code> <code>src/image/</code> Bildladen, Skalierung, Transparenzerkennung <code>lithophane</code> <code>src/lithophane/</code> Konfiguration, Mesh-Generierung, Geometrie <code>stl</code> <code>src/stl/</code> ASCII-/Binaer-STL-Export, ZIP-Verpackung"},{"location":"konzepte/architektur/#datenfluss","title":"Datenfluss","text":"<p>Der vollstaendige Verarbeitungsprozess von der Eingabe bis zur Ausgabe:</p> <pre><code>flowchart LR\n    A[\"Bild laden\"] --&gt; B[\"Skalierung\"]\n    B --&gt; C[\"Palette laden\"]\n    C --&gt; D[\"Farbquantisierung\"]\n    D --&gt; E[\"Mesh-Generierung&lt;br/&gt;(parallel pro Zeile)\"]\n    E --&gt; F[\"STL-Export\"]\n    F --&gt; G[\"ZIP-Archiv\"]</code></pre> <ol> <li>Bild laden - Eingabebild (JPG, PNG, WebP) wird gelesen und dekodiert</li> <li>Skalierung - Das Bild wird auf die Zielgroesse in Millimetern umgerechnet</li> <li>Palette laden - Filament-Definitionen aus der JSON-Palette einlesen</li> <li>Farbquantisierung - Jeder Pixel wird der naechsten verfuegbaren Palettenfarbe zugeordnet</li> <li>Mesh-Generierung - 3D-Geometrie wird parallel erzeugt (eine Zeile pro Thread)</li> <li>STL-Export - Meshes werden als STL-Dateien geschrieben</li> <li>ZIP-Archiv - Alle STL-Dateien werden in ein ZIP-Archiv gepackt</li> </ol>"},{"location":"konzepte/architektur/#module-im-detail","title":"Module im Detail","text":""},{"location":"konzepte/architektur/#color-farbraeume-und-distanzen","title":"<code>color/</code> - Farbraeume und Distanzen","text":"<p>Dieses Modul implementiert drei Farbraeume und die Konvertierung zwischen ihnen:</p> Farbraum Felder Verwendung RGB R, G, B (0-255) Ein-/Ausgabe, Bildverarbeitung HSL H, S, L Palette-Definitionen (Filament-Farben) CIE-Lab L, a, b Wahrnehmungstreue Farbdistanz <p>Die Farbdistanzberechnung unterstuetzt sowohl euklidische RGB-Distanz als auch die perceptuell gleichmaessige CIE-Lab-Distanz (Delta E).</p>"},{"location":"konzepte/architektur/#palette-farbpaletten","title":"<code>palette/</code> - Farbpaletten","text":"<p>Das Palette-Modul hat drei Hauptaufgaben:</p> <ol> <li>Laden - JSON-Paletten-Dateien einlesen und validieren</li> <li>Kombinationsgenerierung - Alle gueltigen Farbkombinationen fuer die konfigurierte Schichtanzahl berechnen</li> <li>Bildquantisierung - Eingabebild-Pixel den naechsten Palettenfarben zuordnen</li> </ol> <pre><code>flowchart TD\n    JSON[\"palette.json\"] --&gt; LOAD[\"PaletteLoader::load()\"]\n    LOAD --&gt; COMBOS[\"Kombinationen generieren\"]\n    COMBOS --&gt; QUANT[\"Bild quantisieren\"]\n    QUANT --&gt; RESULT[\"Quantisiertes Bild\"]</code></pre>"},{"location":"konzepte/architektur/#image-bildverarbeitung","title":"<code>image/</code> - Bildverarbeitung","text":"<p>Verantwortlich fuer:</p> <ul> <li>Bildladen - Unterstuetzt JPEG, PNG, WebP und weitere Formate ueber die <code>image</code>-Crate</li> <li>Skalierung - Anpassung an die Ziel-Millimetergroesse</li> <li>Transparenzerkennung - Erkennung von Alpha-Kanaelen fuer korrekte Verarbeitung</li> <li>Graustufenkonvertierung - Fuer die Texturschicht (Helligkeitsinformation)</li> </ul>"},{"location":"konzepte/architektur/#lithophane-mesh-generierung","title":"<code>lithophane/</code> - Mesh-Generierung","text":"<p>Das Kernmodul mit folgenden Unterkomponenten:</p> Komponente Datei Aufgabe Config <code>config.rs</code> Alle Konfigurationsparameter Generator <code>mod.rs</code> Orchestrierung der Gesamtgenerierung ColorLayer <code>color_layer.rs</code> Farbschichten mit RLE + Quader-Mesh TextureLayer <code>texture_layer.rs</code> Texturschicht mit triangulierten Hoehenprofilen SupportPlate <code>support_plate.rs</code> Grundplatte unter allen Schichten Geometry <code>geometry.rs</code> Mesh, Triangle, Vector3 - Basis-Geometrie <p>Run-Length Encoding (RLE)</p> <p>Benachbarte Pixel gleicher Farbe werden zu einem einzigen breiteren Quader zusammengefasst. Dies reduziert die Anzahl der Dreiecke erheblich und fuehrt zu kleineren STL-Dateien.</p>"},{"location":"konzepte/architektur/#stl-stl-export","title":"<code>stl/</code> - STL-Export","text":"<p>Unterstuetzt zwei Exportformate:</p> Format Vorteil Nachteil Flag ASCII Menschenlesbar, Debug Groessere Dateien <code>--format ascii</code> Binary Kompakt, schneller Nicht lesbar <code>--format binary</code> <p>Die exportierten STL-Dateien werden abschliessend in ein ZIP-Archiv gepackt.</p>"},{"location":"konzepte/architektur/#cli-kommandozeilen-interface","title":"<code>cli/</code> - Kommandozeilen-Interface","text":"<p>Basiert auf der <code>clap</code>-Crate mit dem Derive-Macro. Alle Parameter werden typsicher geparst und in die interne Konfiguration (<code>LithophaneConfig</code>) umgewandelt. Siehe die CLI-Referenz fuer alle verfuegbaren Optionen.</p>"},{"location":"konzepte/architektur/#parallelisierung","title":"Parallelisierung","text":"<p>PIXEstL nutzt Rayon fuer datenparallele Verarbeitung auf Zeilenebene.</p> <pre><code>flowchart TD\n    IMG[\"Eingabebild (N Zeilen)\"] --&gt; PAR[\"Rayon parallel_iter\"]\n    PAR --&gt; R1[\"Zeile 1 verarbeiten\"]\n    PAR --&gt; R2[\"Zeile 2 verarbeiten\"]\n    PAR --&gt; R3[\"Zeile 3 verarbeiten\"]\n    PAR --&gt; RN[\"Zeile N verarbeiten\"]\n    R1 --&gt; MERGE[\"Meshes zusammenfuegen\"]\n    R2 --&gt; MERGE\n    R3 --&gt; MERGE\n    RN --&gt; MERGE\n    MERGE --&gt; OUT[\"Gesamt-Mesh pro Schicht\"]</code></pre>"},{"location":"konzepte/architektur/#prinzip","title":"Prinzip","text":"<ul> <li>Jede Bildzeile wird unabhaengig von den anderen verarbeitet</li> <li>Rayon verteilt die Zeilen automatisch auf alle verfuegbaren CPU-Kerne</li> <li>Nach der parallelen Verarbeitung werden die Teil-Meshes zu einem Gesamt-Mesh zusammengefuegt</li> <li>Die Anzahl der genutzten Threads entspricht standardmaessig der Anzahl der CPU-Kerne</li> </ul> <p>Performance</p> <p>Auf einem 8-Kern-Prozessor ist die Generierung typischerweise 5-7x schneller als bei sequentieller Verarbeitung.</p>"},{"location":"konzepte/architektur/#algorithmen","title":"Algorithmen","text":""},{"location":"konzepte/architektur/#farbquantisierung","title":"Farbquantisierung","text":"<p>Fuer jeden Pixel im Eingabebild wird die naechste verfuegbare Palettenfarbe ermittelt:</p> <ol> <li>Zielfarbe des Pixels in den CIE-Lab-Farbraum konvertieren</li> <li>Distanz zu jeder Palettenfarbe berechnen (Delta E)</li> <li>Palettenfarbe mit der kleinsten Distanz waehlen</li> <li>Zugehoerige Farbschicht-Kombination dem Pixel zuweisen</li> </ol>"},{"location":"konzepte/architektur/#run-length-encoding-rle","title":"Run-Length Encoding (RLE)","text":"<p>Optimierung der Farbschichten fuer kleinere STL-Dateien:</p> <ol> <li>Zeile von links nach rechts durchlaufen</li> <li>Aufeinanderfolgende Pixel gleicher Farbe zaehlen</li> <li>Statt einzelner Quader pro Pixel einen zusammengefassten breiten Quader erzeugen</li> <li>Reduziert die Dreiecksanzahl um typischerweise 40-70%</li> </ol>"},{"location":"konzepte/architektur/#mesh-generierung","title":"Mesh-Generierung","text":"<p>Zwei unterschiedliche Strategien je nach Schichttyp:</p> Schichttyp Geometrie Beschreibung Farbschicht Quader (Cubes) Gleichmaessig hohe Bloecke, Farbe durch Filament Texturschicht Trianguliertes Hoehenprofil Variable Hoehe je nach Pixel-Helligkeit"},{"location":"konzepte/architektur/#abhaengigkeiten","title":"Abhaengigkeiten","text":"<p>Die wichtigsten externen Abhaengigkeiten von PIXEstL:</p> Crate Version Zweck <code>clap</code> 4 Kommandozeilen-Parsing <code>image</code> 0.25 Bildladen und -verarbeitung <code>rayon</code> 1.10 Datenparallele Verarbeitung <code>nalgebra</code> 0.34 Lineare Algebra / Vektoroperationen <code>stl_io</code> 0.10 STL-Datei-Schreiben <code>serde</code> / <code>serde_json</code> 1 JSON-Serialisierung (Paletten) <code>thiserror</code> 2 Ergonomische Fehlertypen <code>anyhow</code> 1 Fehlerbehandlung auf Anwendungsebene <code>zip</code> 8 ZIP-Archiv-Erstellung <code>tracing</code> 0.1 Strukturiertes Logging <code>num_cpus</code> 1 CPU-Kern-Erkennung"},{"location":"konzepte/farbmischung/","title":"CMYK Farbmischung","text":"<p>PIXEstL erzeugt farbige Lithophanien durch CMYK-Farbmischung mit transparenten Filamenten. Diese Seite erklaert die zugrunde liegenden Prinzipien.</p>"},{"location":"konzepte/farbmischung/#grundprinzip","title":"Grundprinzip","text":"<p>Traditionelle Lithophanien sind monochrom (Graustufen). Die Helligkeit eines Pixels wird ausschliesslich ueber die Materialdicke gesteuert: Duenne Bereiche lassen mehr Licht durch und erscheinen hell, dicke Bereiche erscheinen dunkel.</p> <p>PIXEstL geht einen entscheidenden Schritt weiter: Durch das Stapeln transparenter Filamente in den CMYK-Grundfarben entstehen echte Farbbilder. Wenn Licht von hinten durch die gestapelten Schichten faellt, mischen sich die Farben subtraktiv - aehnlich wie beim klassischen Offsetdruck.</p> <p>Subtraktive Farbmischung</p> <p>Bei der subtraktiven Farbmischung absorbiert jede Farbschicht einen Teil des Lichtspektrums. Cyan absorbiert Rot, Magenta absorbiert Gruen, Gelb absorbiert Blau. Durch Kombination der Schichten entstehen beliebige Farben.</p>"},{"location":"konzepte/farbmischung/#cmyk-erklaert","title":"CMYK erklaert","text":"<p>CMYK steht fuer die vier Grundfarben:</p> Abkuerzung Farbe Funktion C Cyan Absorbiert rotes Licht M Magenta Absorbiert gruenes Licht Y Yellow Absorbiert blaues Licht K Key Schwarz - absorbiert alles Licht <p>In PIXEstL wird jede dieser Farben durch ein separates transparentes Filament repraesentiert. Die Schichten werden uebereinander gedruckt. Wenn das fertige Objekt hinterleuchtet wird, durchdringt das Licht alle Schichten und die Farben vermischen sich im Auge des Betrachters.</p> <pre><code>graph TB\n    L[\"Lichtquelle (hinten)\"] --&gt; W[\"Weiss-Schicht\"]\n    W --&gt; C[\"Cyan-Schicht\"]\n    C --&gt; M[\"Magenta-Schicht\"]\n    M --&gt; Y[\"Yellow-Schicht\"]\n    Y --&gt; K[\"Key-Schicht (optional)\"]\n    K --&gt; A[\"Betrachter sieht Mischfarbe\"]</code></pre>"},{"location":"konzepte/farbmischung/#additive-methode","title":"Additive Methode","text":"<p>Die additive Methode ist das Standardverfahren in PIXEstL und erzeugt die groesste Farbvielfalt.</p>"},{"location":"konzepte/farbmischung/#funktionsweise","title":"Funktionsweise","text":"<p>Fuer jeden Pixel werden mehrere Farbschichten gestapelt. Die Gesamtzahl der Schichten ist konfigurierbar (Standard: 5). Die CMYK-Werte der einzelnen Schichten werden aufaddiert, um die Zielfarbe zu erreichen.</p> <p>Beispiel: Helles Cyan</p> <p>Fuer ein helles Cyan bei 5 Gesamtschichten:</p> Schicht Filament 1 Cyan 2 Cyan 3 Weiss 4 Weiss 5 Weiss <p>Ergebnis: 2x Cyan + 3x Weiss = helles, leicht transparentes Cyan.</p> <p>Beispiel: Dunkles Violett</p> Schicht Filament 1 Cyan 2 Cyan 3 Magenta 4 Magenta 5 Magenta <p>Ergebnis: 2x Cyan + 3x Magenta = dunkles Violett.</p>"},{"location":"konzepte/farbmischung/#vorteile","title":"Vorteile","text":"<ul> <li>Grosse Farbvielfalt aus wenigen Filamenten</li> <li>Feine Farbabstufungen moeglich</li> <li>Bessere Farbtreue bei fotorealistischen Bildern</li> </ul>"},{"location":"konzepte/farbmischung/#full-pixel-methode","title":"Full-Pixel Methode","text":"<p>Die Full-Pixel Methode ist eine einfachere Alternative.</p>"},{"location":"konzepte/farbmischung/#funktionsweise_1","title":"Funktionsweise","text":"<p>Bei dieser Methode besteht jeder Pixel aus genau einer Filamentfarbe. Alle Schichten eines Pixels verwenden dasselbe Filament. Es findet keine Mischung zwischen verschiedenen Farben statt.</p> <p>Beispiel</p> <p>Fuer einen Cyan-Pixel bei 5 Gesamtschichten:</p> Schicht Filament 1 Cyan 2 Cyan 3 Cyan 4 Cyan 5 Cyan"},{"location":"konzepte/farbmischung/#vorteile-und-einschraenkungen","title":"Vorteile und Einschraenkungen","text":"Eigenschaft Full-Pixel Additive Farbanzahl Begrenzt (nur Grundfarben) Viele Mischfarben Komplexitaet Gering Hoeher Druckqualitaet Gleichmaessig Farbuebergaenge moeglich Konfiguration <code>--pixel-method full</code> <code>--pixel-method additive</code>"},{"location":"konzepte/farbmischung/#farbabstandsmessung","title":"Farbabstandsmessung","text":"<p>Um fuer jeden Pixel die bestmoegliche Farbe aus der Palette zu finden, muss PIXEstL den Abstand zwischen der Zielfarbe und den verfuegbaren Palettenfarben berechnen. Dafuer stehen zwei Methoden zur Verfuegung.</p>"},{"location":"konzepte/farbmischung/#rgb-distanz","title":"RGB-Distanz","text":"<p>Die einfachste Methode: Euklidischer Abstand im RGB-Farbraum.</p> <pre><code>distanz = sqrt((R1 - R2)^2 + (G1 - G2)^2 + (B1 - B2)^2)\n</code></pre> Eigenschaft Bewertung Geschwindigkeit Sehr schnell Genauigkeit Maessig Wahrnehmungstreue Niedrig <p>Einschraenkung</p> <p>Der RGB-Farbraum ist nicht wahrnehmungsgleichmaessig. Gleiche numerische Distanzen koennen sehr unterschiedlich wahrgenommen werden. Gruene Toene werden beispielsweise feiner unterschieden als blaue.</p>"},{"location":"konzepte/farbmischung/#cie-lab-distanz-standard","title":"CIE-Lab-Distanz (Standard)","text":"<p>Die CIE-Lab-Methode arbeitet im wahrnehmungsgleichmaessigen CIE-Lab-Farbraum. Farben, die fuer das menschliche Auge aehnlich aussehen, haben kleine Distanzen - unabhaengig vom Farbton.</p> <p>Der Abstand wird ueber die Delta-E-Formel berechnet:</p> <p>$$ \\Delta E = \\sqrt{(L_1 - L_2)^2 + (a_1 - a_2)^2 + (b_1 - b_2)^2} $$</p> <p>Dabei stehen die Komponenten fuer:</p> Komponente Bedeutung L Helligkeit (Lightness): 0 = Schwarz, 100 = Weiss a Gruen-Rot-Achse: negativ = Gruen, positiv = Rot b Blau-Gelb-Achse: negativ = Blau, positiv = Gelb <p>Empfehlung</p> <p>CIE-Lab ist der Standard und empfohlene Modus (<code>--color-distance cie-lab</code>). Er liefert deutlich bessere Ergebnisse bei der Farbzuordnung, besonders bei Hauttoenen und feinen Farbverlaeufen.</p>"},{"location":"konzepte/farbmischung/#warum-weiss","title":"Warum Weiss?","text":"<p>Weisses Filament spielt eine zentrale Rolle in der additiven Methode: Es dient als Fuellmaterial.</p> <p>Da jeder Pixel aus einer festen Anzahl von Schichten besteht (Standard: 5), muessen nicht immer alle Schichten eingefaerbt sein. Weiss fuellt die verbleibenden Schichten auf, damit die Gesamtdicke konstant bleibt.</p> <pre><code>graph LR\n    subgraph \"Dunkles Rot (5 Schichten)\"\n        A1[\"Magenta\"] --- A2[\"Magenta\"] --- A3[\"Magenta\"] --- A4[\"Yellow\"] --- A5[\"Yellow\"]\n    end\n\n    subgraph \"Helles Rosa (5 Schichten)\"\n        B1[\"Magenta\"] --- B2[\"Weiss\"] --- B3[\"Weiss\"] --- B4[\"Weiss\"] --- B5[\"Weiss\"]\n    end</code></pre> <p>Pflicht in der additiven Methode</p> <p>In der additiven Methode ist Weiss zwingend erforderlich. Ohne Weiss als Fuellfarbe koennte PIXEstL keine hellen Toene erzeugen. Stelle sicher, dass deine Palette immer ein weisses Filament enthaelt.</p>"},{"location":"konzepte/farbmischung/#farbkombinationen","title":"Farbkombinationen","text":"<p>Bei der additiven Methode generiert PIXEstL alle gueltigen Kombinationen aus den verfuegbaren Farben fuer die konfigurierte Schichtanzahl.</p>"},{"location":"konzepte/farbmischung/#beispiel-5-schichten-mit-cmyk-weiss","title":"Beispiel: 5 Schichten mit CMYK + Weiss","text":"<p>Mit 5 Schichten und 5 moeglichen Farben (C, M, Y, K, W) ergeben sich Kombinationen wie:</p> Cyan Magenta Yellow Key Weiss Ergebnis 0 0 0 0 5 Reines Weiss 5 0 0 0 0 Sattes Cyan 2 0 0 0 3 Helles Cyan 1 1 1 0 2 Helles Grau 2 2 0 0 1 Blau-Violett 0 3 2 0 0 Rot-Orange 1 0 2 1 1 Oliv-Gruen 0 0 0 5 0 Tiefschwarz <p>Gesamtzahl der Kombinationen</p> <p>Die Anzahl der moeglichen Kombinationen entspricht der Anzahl der Moeglichkeiten, <code>n</code> Schichten auf <code>k</code> Farben zu verteilen. Fuer 5 Schichten und 5 Farben sind das 126 eindeutige Kombinationen. Nicht alle erzeugen visuell unterscheidbare Farben - PIXEstL waehlt automatisch die beste Uebereinstimmung fuer jeden Pixel.</p>"},{"location":"referenz/palette-format/","title":"Palette-Format","text":"<p>Die Palette-Datei ist das Herzst\u00fcck der Farbkalibrierung. Sie sagt PIXEstL genau, wie deine Filamente hinterleuchtet aussehen \u2013 und das f\u00fcr verschiedene Schichtdicken.</p>"},{"location":"referenz/palette-format/#wozu-dient-die-palette","title":"Wozu dient die Palette?","text":"<p>Transparente Filamente sehen hinterleuchtet je nach Schichtdicke unterschiedlich aus: Eine einzelne Schicht Cyan ist sehr hell und blass, f\u00fcnf Schichten \u00fcbereinander sind satt und dunkel.</p> <p>PIXEstL speichert diese Unterschiede pro Filament und Schichtanzahl in der Palette-Datei und berechnet damit die optimale Mischung f\u00fcr jeden Pixel deines Bildes.</p>"},{"location":"referenz/palette-format/#json-grundstruktur","title":"JSON-Grundstruktur","text":"<p>Die Palette ist ein JSON-Objekt. Jeder Schl\u00fcssel ist ein Hex-Farbcode, der Wert enth\u00e4lt alle Informationen zum Filament:</p> <pre><code>{\n  \"#0086D6\": {\n    \"name\": \"Cyan[PLA Basic]\",\n    \"active\": true,\n    \"layers\": {\n      \"1\": { \"H\": 201.9, \"S\": 96.4, \"L\": 78.2 },\n      \"2\": { \"H\": 199.5, \"S\": 100,  \"L\": 64.3 },\n      \"3\": { \"H\": 199.8, \"S\": 91.5, \"L\": 53.9 },\n      \"4\": { \"H\": 200.6, \"S\": 95.9, \"L\": 47.6 },\n      \"5\": { \"H\": 203.8, \"S\": 99.1, \"L\": 45.3 }\n    }\n  }\n}\n</code></pre>"},{"location":"referenz/palette-format/#felder-erklart","title":"Felder erkl\u00e4rt","text":"Feld Typ Beschreibung Hex-Key (z.B. <code>\"#0086D6\"</code>) String Eindeutiger Bezeichner des Filaments im Format <code>#RRGGBB</code>. Wird im Slicer zur Farbanzeige verwendet. <code>name</code> String Lesbarer Name des Filaments, z.B. <code>\"Cyan[PLA Basic]\"</code>. Wird f\u00fcr die Benennung der STL-Ausgabedateien verwendet. <code>active</code> Boolean <code>true</code> = Filament wird bei der Generierung verwendet. <code>false</code> = Filament wird ignoriert (aber bleibt in der Datei). <code>layers</code> Objekt Enth\u00e4lt die Schl\u00fcssel <code>\"1\"</code> bis <code>\"5\"</code> (oder mehr). Jeder Schl\u00fcssel enth\u00e4lt die gemessenen HSL-Werte f\u00fcr diese Schichtanzahl. <code>H</code> Zahl Hue (Farbton) in Grad, Bereich 0\u2013360. Rot \u2248 0, Gr\u00fcn \u2248 120, Blau \u2248 240. <code>S</code> Zahl Saturation (S\u00e4ttigung) in Prozent, Bereich 0\u2013100. 0 = Grau, 100 = volle Farbe. <code>L</code> Zahl Lightness (Helligkeit) in Prozent, Bereich 0\u2013100. 0 = Schwarz, 50 = reine Farbe, 100 = Wei\u00df. <p>So \u00e4ndern sich die Werte mit der Schichtanzahl:</p> <ul> <li>Schicht 1 (d\u00fcnnste): Sehr heller Wert, hohe Lightness (L) \u2013 wenig Filament filtert kaum Licht.</li> <li>Schicht 5 (dickste): Dunkler/s\u00e4ttigster Wert, niedrige Lightness (L) \u2013 mehr Filament absorbiert mehr Licht.</li> <li>Hue (H) bleibt \u00fcber alle Schichten ungef\u00e4hr gleich.</li> <li>Saturation (S) steigt typischerweise mit der Schichtanzahl.</li> <li>Lightness (L) sinkt mit der Schichtanzahl.</li> </ul>"},{"location":"referenz/palette-format/#minimal-beispiel-wei-eine-farbe","title":"Minimal-Beispiel (Wei\u00df + eine Farbe)","text":"<p>Das kleinstm\u00f6gliche g\u00fcltige Beispiel mit nur zwei Filamenten:</p> <pre><code>{\n  \"#FFFFFF\": {\n    \"name\": \"White[PLA Basic]\",\n    \"active\": true,\n    \"layers\": {\n      \"1\": { \"H\": 0, \"S\": 0, \"L\": 95 },\n      \"2\": { \"H\": 0, \"S\": 0, \"L\": 95 },\n      \"3\": { \"H\": 0, \"S\": 0, \"L\": 85 },\n      \"4\": { \"H\": 0, \"S\": 0, \"L\": 85 },\n      \"5\": { \"H\": 0, \"S\": 0, \"L\": 85 }\n    }\n  },\n  \"#0086D6\": {\n    \"name\": \"Cyan[PLA Basic]\",\n    \"active\": true,\n    \"layers\": {\n      \"1\": { \"H\": 201.9, \"S\": 96.4, \"L\": 78.2 },\n      \"2\": { \"H\": 199.5, \"S\": 100,  \"L\": 64.3 },\n      \"3\": { \"H\": 199.8, \"S\": 91.5, \"L\": 53.9 },\n      \"4\": { \"H\": 200.6, \"S\": 95.9, \"L\": 47.6 },\n      \"5\": { \"H\": 203.8, \"S\": 99.1, \"L\": 45.3 }\n    }\n  }\n}\n</code></pre> <p>Wei\u00df ist Pflicht</p> <p>Wei\u00df muss immer in der Palette enthalten und <code>active: true</code> sein. Es dient als F\u00fcllmaterial f\u00fcr Pixel, die weniger als 5 Farbschichten ben\u00f6tigen. Ohne Wei\u00df kann PIXEstL keine Farbmischung berechnen.</p>"},{"location":"referenz/palette-format/#vollstandiges-beispiel-cmyk-set","title":"Vollst\u00e4ndiges Beispiel (CMYK-Set)","text":"<p>Eine vollst\u00e4ndige CMYK-Palette mit den vier Grundfarben:</p> <pre><code>{\n  \"#FFFFFF\": {\n    \"name\": \"White[PLA Basic]\",\n    \"active\": true,\n    \"layers\": {\n      \"1\": { \"H\": 0,   \"S\": 0,    \"L\": 95   },\n      \"2\": { \"H\": 0,   \"S\": 0,    \"L\": 95   },\n      \"3\": { \"H\": 0,   \"S\": 0,    \"L\": 85   },\n      \"4\": { \"H\": 0,   \"S\": 0,    \"L\": 85   },\n      \"5\": { \"H\": 0,   \"S\": 0,    \"L\": 85   }\n    }\n  },\n  \"#0086D6\": {\n    \"name\": \"Cyan[PLA Basic]\",\n    \"active\": true,\n    \"layers\": {\n      \"1\": { \"H\": 201.9, \"S\": 96.4, \"L\": 78.2 },\n      \"2\": { \"H\": 199.5, \"S\": 100,  \"L\": 64.3 },\n      \"3\": { \"H\": 199.8, \"S\": 91.5, \"L\": 53.9 },\n      \"4\": { \"H\": 200.6, \"S\": 95.9, \"L\": 47.6 },\n      \"5\": { \"H\": 203.8, \"S\": 99.1, \"L\": 45.3 }\n    }\n  },\n  \"#EC008C\": {\n    \"name\": \"Magenta[PLA Basic]\",\n    \"active\": true,\n    \"layers\": {\n      \"1\": { \"H\": 322.0, \"S\": 97.0, \"L\": 77.5 },\n      \"2\": { \"H\": 321.5, \"S\": 99.0, \"L\": 63.0 },\n      \"3\": { \"H\": 322.0, \"S\": 95.0, \"L\": 52.0 },\n      \"4\": { \"H\": 322.5, \"S\": 98.0, \"L\": 45.0 },\n      \"5\": { \"H\": 323.0, \"S\": 100,  \"L\": 40.0 }\n    }\n  },\n  \"#FCE300\": {\n    \"name\": \"Yellow[PLA Basic]\",\n    \"active\": true,\n    \"layers\": {\n      \"1\": { \"H\": 53.0, \"S\": 97.0, \"L\": 83.0 },\n      \"2\": { \"H\": 52.5, \"S\": 98.0, \"L\": 72.0 },\n      \"3\": { \"H\": 52.0, \"S\": 99.0, \"L\": 62.0 },\n      \"4\": { \"H\": 51.5, \"S\": 100,  \"L\": 55.0 },\n      \"5\": { \"H\": 51.0, \"S\": 100,  \"L\": 49.0 }\n    }\n  }\n}\n</code></pre> <p>Werte anpassen</p> <p>Die Werte im Beispiel sind f\u00fcr Bambu Lab PLA Basic kalibriert. F\u00fcr andere Filamente musst du deine eigenen Werte messen \u2013 die Abweichungen k\u00f6nnen erheblich sein.</p>"},{"location":"referenz/palette-format/#alternativer-hex-string-notation","title":"Alternativer Hex-String-Notation","text":"<p>Statt HSL-Werte einzeln anzugeben, kannst du auch direkt Hex-Farbcodes pro Schicht angeben:</p> <pre><code>{\n  \"#FF5500\": {\n    \"name\": \"Orange[Beispiel]\",\n    \"active\": true,\n    \"layers\": {\n      \"1\": \"#FFD4B0\",\n      \"2\": \"#FFB87A\",\n      \"3\": \"#FF9C4A\",\n      \"4\": \"#FF7B1A\",\n      \"5\": \"#FF5500\"\n    }\n  }\n}\n</code></pre> <p>PIXEstL konvertiert diese Hex-Werte automatisch in HSL. Diese Notation ist praktisch, wenn du Farben direkt aus einem Farbw\u00e4hler einf\u00fcgst.</p>"},{"location":"referenz/palette-format/#farben-aktivieren-und-deaktivieren","title":"Farben aktivieren und deaktivieren","text":"<p>Mit <code>\"active\": false</code> kannst du Farben vor\u00fcbergehend ausschalten, ohne sie zu l\u00f6schen:</p> <pre><code>{\n  \"#FFE34F\": {\n    \"name\": \"Pale Yellow[OVERTURE]\",\n    \"active\": false,\n    \"layers\": { \"...\" }\n  }\n}\n</code></pre> <p>Sinnvoll wenn: - Das Filament gerade nicht vorr\u00e4tig ist - Du testen m\u00f6chtest, wie die Lithophanie ohne eine bestimmte Farbe aussieht - Dein AMS weniger Slots hat, als die Palette Farben enth\u00e4lt</p>"},{"location":"referenz/palette-format/#haufige-fehler-im-json","title":"H\u00e4ufige Fehler im JSON","text":"JSON-Syntaxfehler: fehlendes Komma <pre><code>// FALSCH \u2013 fehlendes Komma nach dem ersten Eintrag\n{\n  \"#FFFFFF\": { ... }\n  \"#0086D6\": { ... }\n}\n\n// RICHTIG\n{\n  \"#FFFFFF\": { ... },\n  \"#0086D6\": { ... }\n}\n</code></pre> Letztes Komma (Trailing Comma) <pre><code>// FALSCH \u2013 JSON erlaubt kein Komma nach dem letzten Eintrag\n{\n  \"1\": { \"H\": 200, \"S\": 90, \"L\": 70 },\n  \"2\": { \"H\": 199, \"S\": 92, \"L\": 60 },  \u2190 Komma hier ist ein Fehler\n}\n</code></pre> Falscher Hex-Key-Format <pre><code>// FALSCH \u2013 fehlende Raute oder Kleinbuchstaben\n\"0086D6\": { ... }\n\"#0086d6\": { ... }\n\n// RICHTIG \u2013 Raute + Gro\u00dfbuchstaben\n\"#0086D6\": { ... }\n</code></pre> Kein Wei\u00df-Eintrag <p>PIXEstL gibt eine Fehlermeldung aus, wenn die Palette keinen aktiven Wei\u00df-Eintrag enth\u00e4lt. Wei\u00df muss immer vorhanden sein.</p>"},{"location":"referenz/palette-format/#palette-validieren","title":"Palette validieren","text":"<pre><code>pixestl --palette-info -p deine-palette.json\n</code></pre> <p>Dieser Befehl zeigt alle aktiven Farben, die Anzahl der Layer-Definitionen und warnt bei fehlenden oder inkonsistenten Eintr\u00e4gen.</p>"},{"location":"referenz/palette-format/#nachster-schritt","title":"N\u00e4chster Schritt","text":"<ul> <li>Palette kalibrieren \u2192 \u2013 Wie du eigene HSL-Werte misst</li> <li>Alle Parameter \u2192 \u2013 Vollst\u00e4ndige CLI-Referenz</li> </ul>"},{"location":"referenz/parameter/","title":"Alle Parameter \u2013 Referenz","text":"<p>Vollst\u00e4ndige \u00dcbersicht aller Kommandozeilen-Parameter von PIXEstL.</p>"},{"location":"referenz/parameter/#aufruf-syntax","title":"Aufruf-Syntax","text":"<pre><code># Farb-Lithophanie generieren\npixestl [OPTIONEN] -i &lt;BILD&gt; -p &lt;PALETTE&gt; -o &lt;AUSGABE&gt;\n\n# Kalibrierungs-Testmuster generieren\npixestl --calibrate -p &lt;PALETTE&gt; -o &lt;AUSGABE&gt;\n\n# Palette-Informationen anzeigen\npixestl --palette-info -p &lt;PALETTE&gt;\n</code></pre>"},{"location":"referenz/parameter/#pflichtfelder","title":"Pflichtfelder","text":"<p>Diese Parameter m\u00fcssen beim regul\u00e4ren Aufruf angegeben werden.</p> Parameter Kurzform Beschreibung <code>--input</code> <code>-i</code> Pfad zum Eingabebild (JPG, PNG, WebP). Nicht n\u00f6tig bei <code>--calibrate</code> oder <code>--palette-info</code>. <code>--palette</code> <code>-p</code> Pfad zur Palette-Datei (JSON mit Filament-Farbdaten) <code>--output</code> <code>-o</code> Pfad zur Ausgabe-ZIP-Datei (enth\u00e4lt alle STL-Dateien). Nicht n\u00f6tig bei <code>--palette-info</code>. <p>Wann es Sinn macht zu \u00e4ndern: Diese Werte \u00e4nderst du bei jedem Aufruf \u2013 sie sind immer bildspezifisch.</p> <p>Minimalbeispiel</p> <pre><code>pixestl -i foto.jpg -p palette/filament-palette-0.10mm.json -o ausgabe.zip\n</code></pre>"},{"location":"referenz/parameter/#dimensionen","title":"Dimensionen","text":"<p>Steuern die physische Gr\u00f6\u00dfe der fertigen Lithophanie in Millimetern.</p> Parameter Kurzform Standard Beschreibung <code>--width</code> <code>-w</code> <code>0</code> Breite der Lithophanie in mm. <code>0</code> = automatisch aus H\u00f6he berechnen. <code>--height</code> <code>-H</code> <code>0</code> H\u00f6he der Lithophanie in mm. <code>0</code> = automatisch aus Breite berechnen. <p>Wann es Sinn macht: Gib mindestens einen Wert an. <code>0</code> bei beiden Werten f\u00fchrt zu einer Fehlermeldung. Wenn nur Breite oder nur H\u00f6he angegeben wird, berechnet PIXEstL die andere Dimension proportional aus dem Seitenverh\u00e4ltnis des Bildes.</p> <p>Beispiele</p> <pre><code># 100 mm breit, H\u00f6he proportional\npixestl -i foto.jpg -p palette.json -o out.zip -w 100\n\n# 80 mm hoch, Breite proportional\npixestl -i foto.jpg -p palette.json -o out.zip -H 80\n\n# Exakt 120\u00d780 mm (kann Bild verzerren)\npixestl -i foto.jpg -p palette.json -o out.zip -w 120 -H 80\n</code></pre>"},{"location":"referenz/parameter/#farb-ebene","title":"Farb-Ebene","text":"<p>Parameter f\u00fcr die CMYK-Farbschichten \u2013 das Herzst\u00fcck der Farb-Lithophanie.</p> Parameter Standard Beschreibung <code>--color-pixel-width</code> <code>0.8</code> mm Breite eines einzelnen Farbpixels. Kleinere Werte = mehr Details, aber auch gr\u00f6\u00dfere STL-Dateien und l\u00e4ngere Druckzeiten. <code>--color-layer-thickness</code> <code>0.1</code> mm Dicke einer einzelnen Farbschicht. Muss exakt mit der Schichth\u00f6he im Slicer \u00fcbereinstimmen. <code>--color-layers</code> <code>5</code> Anzahl der Farbschichten pro Pixel (1\u20135). Mehr Schichten = mehr Farbt\u00f6ne m\u00f6glich. <code>--no-color</code> \u2013 (Flag) Deaktiviert alle Farbschichten. Erzeugt eine klassische Graustufen-Lithophanie. <p>Wann es Sinn macht: - <code>--color-pixel-width 0.5</code>: Wenn du sehr feine Details willst und dir l\u00e4ngere Druckzeiten egal sind. - <code>--color-layers 3</code>: F\u00fcr schnellere Drucke mit weniger Farbtiefe. - <code>--no-color</code>: F\u00fcr erste Tests oder wenn du kein AMS hast.</p> <p>Schichtdicke und Kalibrierung</p> <p>Der Wert <code>--color-layer-thickness</code> muss exakt der Schichth\u00f6he entsprechen, f\u00fcr die deine Palette kalibriert wurde. Die mitgelieferte Beispiel-Palette ist f\u00fcr 0.10 mm kalibriert. Wenn du 0.08 mm im Slicer verwendest, brauchst du eine neu kalibrierte Palette.</p>"},{"location":"referenz/parameter/#textur-ebene","title":"Textur-Ebene","text":"<p>Parameter f\u00fcr die Texturschicht \u2013 sie kodiert die Helligkeit des Bildes als physische Dicke.</p> Parameter Standard Beschreibung <code>--texture-pixel-width</code> <code>0.25</code> mm Aufl\u00f6sung der Texturschicht. Feiner als Farbpixel, um Helligkeitsverl\u00e4ufe detailliert abzubilden. <code>--texture-min</code> <code>0.3</code> mm Minimale Texturdicke (hellste Bildstelle). D\u00fcnner = mehr Licht durch helle Bereiche. <code>--texture-max</code> <code>1.8</code> mm Maximale Texturdicke (dunkelste Bildstelle). Dicker = weniger Licht durch dunkle Bereiche. <code>--no-texture</code> \u2013 (Flag) Deaktiviert die Texturschicht. Nur Farbschichten werden erzeugt (f\u00fcr Tests). <p>Wann es Sinn macht: - <code>--texture-min 0.2</code> + <code>--texture-max 2.2</code>: F\u00fcr mehr Kontrast bei sehr flachen Bildern. - <code>--texture-pixel-width 0.2</code>: F\u00fcr feinere Helligkeitsdetails bei gr\u00f6\u00dferen Lithophanien. - <code>--no-texture</code>: Selten sinnvoll \u2013 Texturschicht gibt der Lithophanie Tiefe und Kontrast.</p>"},{"location":"referenz/parameter/#export","title":"Export","text":"<p>Parameter f\u00fcr das Ausgabeformat der STL-Dateien.</p> Parameter Standard Beschreibung <code>--format</code> <code>ascii</code> STL-Format: <code>ascii</code> (lesbar) oder <code>binary</code> (klein, schnell). <code>--plate-thickness</code> <code>0.2</code> mm Dicke der Grundplatte, auf der alle Farbschichten aufbauen. <p>Wann es Sinn macht: - <code>--format binary</code>: Fast immer empfehlenswert \u2013 erzeugt 50\u201380 % kleinere Dateien, die schneller vom Slicer geladen werden. - <code>--plate-thickness 0.4</code>: Wenn du eine stabilere Grundplatte m\u00f6chtest.</p> <p>Binary immer verwenden</p> <pre><code>pixestl -i foto.jpg -p palette.json -o out.zip -w 100 --format binary\n</code></pre>"},{"location":"referenz/parameter/#krummung-curve","title":"Kr\u00fcmmung (Curve)","text":"<p>Erzeugt zylindrisch gekr\u00fcmmte Lithophanien statt flacher Platten \u2013 ideal f\u00fcr Lampenschirme und Panoramabilder.</p> Parameter Kurzform Standard Beschreibung <code>--curve</code> <code>-C</code> <code>0</code> Kr\u00fcmmungswinkel in Grad. 0 = flach, 90 = Viertelzylinder, 180 = Halbzylinder, 360 = Vollzylinder. Wert Ergebnis <code>0</code> Flach (Standard) <code>90</code> Viertelzylinder <code>180</code> Halbzylinder \u2013 steht frei aufgestellt <code>360</code> Vollzylinder \u2013 ideal f\u00fcr Lampen und Vasen <p>Wann es Sinn macht: - <code>180</code>: Panoramafotos als freistehendes Leuchtbild. - <code>360</code>: Als Lampenschirm \u2013 das Bild wickelt sich einmal komplett um.</p> <p>Beispiele</p> <pre><code># Halbzylinder\npixestl -i panorama.jpg -p palette.json -o out.zip -w 200 -C 180\n\n# Vollzylinder-Lampenschirm\npixestl -i bild.jpg -p palette.json -o out.zip -w 250 -C 360\n</code></pre>"},{"location":"referenz/parameter/#erweitert","title":"Erweitert","text":"<p>Parameter f\u00fcr Feinsteuerung, AMS-Betrieb und Debugging.</p> Parameter Standard Beschreibung <code>--color-distance</code> <code>cie-lab</code> Methode f\u00fcr den Farbvergleich: <code>cie-lab</code> (wahrnehmungstreu, empfohlen) oder <code>rgb</code> (schneller, weniger genau). <code>--pixel-method</code> <code>additive</code> Wie Pixel erzeugt werden: <code>additive</code> (transparente Schichten stapeln) oder <code>full</code> (ein Pixel = eine Farbe). <code>--color-number</code> <code>0</code> Maximale Farbanzahl pro Druckgruppe f\u00fcr AMS. <code>0</code> = alle Farben, <code>4</code> = 1 AMS, <code>8</code> = 2 AMS, <code>16</code> = 4 AMS. <code>--calibrate</code> \u2013 (Flag) Kalibrierungsmodus: Erzeugt Testmuster statt Lithophanie. Kein Eingabebild n\u00f6tig. <code>--palette-info</code> \u2013 (Flag) Zeigt Informationen \u00fcber die geladene Palette an (aktive Farben, Layer-Definitionen). <code>--debug</code> \u2013 (Flag) Gibt zus\u00e4tzliche Debug-Informationen in der Konsole aus. <p>Wann es Sinn macht: - <code>--color-number 4</code>: Wenn du nur ein AMS (4 Slots) hast \u2013 PIXEstL teilt die Farben in Gruppen auf. - <code>--pixel-method full</code>: F\u00fcr einfache Logos oder Grafiken ohne Farbmischung. - <code>--color-distance rgb</code>: Selten \u2013 nur wenn CIE-Lab f\u00fcr eine bestimmte Palette schlechtere Ergebnisse liefert.</p> AMS-Konfiguration Parameter 1 AMS (4 Slots) <code>--color-number 4</code> 2 AMS (8 Slots) <code>--color-number 8</code> 4 AMS (16 Slots) <code>--color-number 16</code> Alles auf einmal <code>--color-number 0</code> (Standard)"},{"location":"referenz/parameter/#vollstandige-beispiele","title":"Vollst\u00e4ndige Beispiele","text":""},{"location":"referenz/parameter/#standard-lithophanie-100-mm","title":"Standard-Lithophanie (100 mm)","text":"<pre><code>pixestl \\\n  -i foto.jpg \\\n  -p palette/filament-palette-0.10mm.json \\\n  -o ausgabe.zip \\\n  -w 100 \\\n  --format binary\n</code></pre>"},{"location":"referenz/parameter/#hochauflosend-mit-feinen-pixeln","title":"Hochaufl\u00f6send mit feinen Pixeln","text":"<pre><code>pixestl \\\n  -i foto.jpg \\\n  -p palette/filament-palette-0.10mm.json \\\n  -o ausgabe_fein.zip \\\n  -w 150 \\\n  --color-pixel-width 0.5 \\\n  --texture-pixel-width 0.2 \\\n  --format binary\n</code></pre>"},{"location":"referenz/parameter/#nur-textur-klassische-graustufen-lithophanie","title":"Nur Textur \u2013 klassische Graustufen-Lithophanie","text":"<pre><code>pixestl \\\n  -i foto.jpg \\\n  -p palette/filament-palette-0.10mm.json \\\n  -o graustufen.zip \\\n  -w 100 \\\n  --no-color\n</code></pre>"},{"location":"referenz/parameter/#halbzylinder-fur-panoramafotos","title":"Halbzylinder f\u00fcr Panoramafotos","text":"<pre><code>pixestl \\\n  -i panorama.jpg \\\n  -p palette/filament-palette-0.10mm.json \\\n  -o panorama.zip \\\n  -w 200 \\\n  -C 180 \\\n  --format binary\n</code></pre>"},{"location":"referenz/parameter/#kalibrierungs-testmuster","title":"Kalibrierungs-Testmuster","text":"<pre><code>pixestl --calibrate \\\n  -p palette/filament-palette-0.10mm.json \\\n  -o kalibrierung.zip \\\n  --color-layers 5\n</code></pre>"},{"location":"referenz/parameter/#nachster-schritt","title":"N\u00e4chster Schritt","text":"<ul> <li>Palette-Format \u2192 \u2013 Wie die Palette-JSON aufgebaut ist</li> <li>Anleitung: Generierung \u2192 \u2013 Parameter in der Praxis anwenden</li> </ul>"}]}